<!doctype html>
<html lang="en">
	<head>
		Access-Control-Allow-Origin: *
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<!--  -->
<section>
	<h1>Rust Fundamentals</h1>
</section>


<!-- Agenda -->
<section>
	<h2>Agenda</h2>
	<ul>
		<li>Basics of Rust</li>
		<li>Data types</li>
		<li>Functions</li>
		<li>Strings</li>
		<li>Memory Management</li>
		<li>Control Flow</li>
		<li>Ownership</li>
		<li>Traits</li>
		<li>Generic types</li>
		<li>Error Handling</li>
		<li>Concurrency</li>
		<li>Async and Await</li>
	</ul>
</section>

<section>
	<h1>Basics of Rust</h1>
</section>

<section>
	<h2>Getting Started</h2>
	<ol>
		<li>
			How to install rust.
			<p>
				<a href="https://www.rust-lang.org/learn/get-started">https://www.rust-lang.org/learn/get-started</a>
			</p>
		</li>
		<li>
			Rust tools.
			<ul>
				<li><a href="https://rustup.rs/">rustup</a></li>
				<li>cargo</li>
				<li>rustc</a></li>
				<li><a href="https://crates.io/">crates.io</a></li>
			</ul>
		</li>
		<li>
			<a href="https://codesandbox.io/p/sandbox/basics-of-rust-kbv4b4">Rust Project Structure</a>
		</li>
	</ol>
</section>

<section>
	<h1>Data Types</h1>
</section>

<section>
	<h2 data-id="code-title">Variables and Mutability</h2>

	<p>Variables are immutable by default</p>

	<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
		fn main() {
			let x = 5;
			println!("The value of x is: {x}");
			x = 6;
			println!("The value of x is: {x}");
		}		
	</code></pre>
</section>

<section>
	<h2 data-id="code-title">Variables and Mutability</h2>
	<p>Error message displayed</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
		$ cargo run
		Compiling variables v0.1.0 (file:///projects/variables)
		error[E0384]: cannot assign twice to immutable variable `x`
			--> src/main.rs:4:5
		2  |     let x = 5;
		   |         -
		   |         |
		   |         first assignment to `x`
		   |         help: consider making this binding mutable: `mut x`
		3  |     println!("The value of x is: {x}");
		4  |     x = 6;
		   |     ^^^^^ cannot assign twice to immutable variable
			For more information about this error, try `rustc --explain E0384`.
			error: could not compile `variables` due to previous error
		</code>
	</pre>
</section>

<section>
	<h2 data-id="code-title">Mutability</h2>
	<p>How do we fix the error?</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let mut x = 5;
				println!("The value of x is: {x}");
				x = 6;
				println!("The value of x is: {x}");
			}			
		</code>
	</pre>
	<p>Output</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			$ cargo run
			Compiling variables v0.1.0 (file:///projects/variables)
			 Finished dev [unoptimized + debuginfo] target(s) in 0.30s
			  Running `target/debug/variables`
		 The value of x is: 5
		 The value of x is: 6		 
		</code>
	</pre>
</section>

<section>
	<h2>Constants</h2>
	<ul>
		<li>Constants are values that are bound to a name and are not allowed to change</li>
		<li>mut is not used with constant</li>
		<li>You declare constants using the const keyword instead of the let keyword, and the type of the value must be annotated</li>
	</ul>
</section>

<section>
	<h2>Constants</h2>
	<ul>
		<li>Constants can be declared in any scope, including the global scope</li>
		<li>Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
			}					 
		</code>
	</pre>
</section>

<section>
	<h2>Shadowing</h2>
	<ul>
		<li>You can declare a new variable with the same name as a previous variable</li>
		<li>The first variable is shadowed by the second</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let x = 5;
				let x = x + 1;
				{
					let x = x * 2;
					println!("The value of x in the inner scope is: {x}");
				
				println!("The value of x is: {x}");
			}
		</code>
	</pre>
</section>

<section>
	<h2>Data Types</h2>
	<ul>
		<li>Data type subsets: <em>scalar</em> and <em>compound</em></li>
		<li>Rust is a statically typed language, which means that it must know the types of all variables at compile time</li>
	</ul>
</section>

<section>
	<h2>Scalar Types</h2>
	<ul>
		<li>Constants can be declared in any scope, including the global scope</li>
		<li>A scalar type represents a single value</li>
		<ul>
			<li>Integers</li>
			<li>Floating-point numbers</li>
			<li>Booleans</li>
			<li>Characters</li>
		</ul>
	</ul>
</section>

<section>
	<h2>Integer Types</h2>
	<p>integer is a number without a fractional component</p>
	<table>
		<thead>
			<tr>
				<th>Number literals</th>
				<th>Example</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>Decimal</td>
				<td>98_222</td>
			</tr>
			<tr>
				<td>Hex</td>
				<td>0xff</td>
			</tr>
			<tr>
				<td>Octal</td>
				<td>0o77</td>
			</tr>
			<tr>
				<td>Binary</td>
				<td>0b1111_0000</td>
			</tr>
			<tr>
				<td>Byte (u8 only)</td>
				<td>b'A'</td>
			</tr>
		</tbody>
	</table>
</section>

<section>
	<h2>Floating-Point Types</h2>
	<ul>
		<li>Numbers with decimal points</li>
		<li>Rust‚Äôs floating-point types are f32 and f64</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let x = 2.0;	// f64
				let y: f32 = 3.0; 	// f32
			}					 
		</code>
	</pre>
</section>

<section>
	<h2>Numeric Operations</h2>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				// addition
				let sum = 5 + 10;
				// subtraction
				let difference = 95.5 - 4.3;
				// multiplication
				let product = 4 * 30;
				// division
				let quotient = 56.7 / 32.2;
				let truncated = -5 / 3; // Results in -1
				// remainder
				let remainder = 43 % 5;
			}								 
		</code>
	</pre>
</section>

<section>
	<h2>The Boolean Type</h2>
	<ul>
		<li>Rust has two possible values: true and false</li>
		<li>Booleans are one byte in size</li>
		<li>It is specified using bool</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let t = true;
			
				let f: bool = false; // with explicit type annotation
			}								 
		</code>
	</pre>
</section>

<section>
	<h2>The Character Type</h2>
	<ul>
		<li>Rust‚Äôs char type is the language‚Äôs most primitive alphabetic type</li>
		<li>Specify char literals with single quotes</li>
		<li>Rust‚Äôs char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let c = 'z';
				let z: char = '‚Ñ§'; // with explicit type annotation
				let heart_eyed_cat = 'üòª'; //emoji
			}					 
		</code>
	</pre>
</section>

<section>
	<h2>Compound Types</h2>
	<ul>
		<li>Compound types can group multiple values into one type</li>
		<li>Rust has two primitive compound types: tuples and arrays</li>
	</ul>
</section>


<section>
	<h2>Compound Types</h2>
	<p><strong>Exercise-1</strong></p>
	<p><small>(clue: all the array elements should be of same type)</small></p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let x = 2.0;	// f64
				let y: f32 = 3.0; 	// f32
			}					 
		</code>
		<a href="https://codesandbox.io/p/sandbox/rusttrainingexamples-forked-lzz4h8?file=%2Fexamples%2Ftypeerror.rs">Run in online editor</a>
	</pre>
</section>

<section>
	<h2>Compound Types</h2>
	<p><strong>Exercise-2</strong></p>
	<p><small>(clue: indexing should start from 0)</small></p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let arr = ['a', 'b', 'c'];
				let ele = arr[1]; // Only modify this line to make the code work!
				assert!(ele == 'a');
				println!("Success!");
			}
		</code>
		<a href="https://codesandbox.io/p/sandbox/elegant-curie-w3wxp4?file=%2Fexamples%2Farrayindexing.rs">Run in online editor</a>
	</pre>
	
</section>

<section>
	<h2>The Tuple Type</h2>
	<ul>
		<li>A tuple is a general way of grouping together a number of values with a variety of types into one compound type</li>
	</ul>
	<ul>
		<li><strong>Fixed length</strong></li>
		<li><strong>Known at Compile time</strong></li>
		<li><strong>Homogeneous</strong></li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				// creating tuple
				let tup: (i32, f64, u8) = (500, 6.4, 1);
				let gfg: (&str, &str, &str) = ("Apple", "For", "Bananas");
				// accessing tuple data using positional argument
				println!("{} {} {}", gfg.0, gfg.1, gfg.2);
				// creating another tuple
				let article = ("abc", "xyz", 14,12,2020);
				let (a,b,c,d,e) = article;
				// accessing tuple using variables
				println!("This written by {} at {} on {}/{}/{}", b,a,c,d,e);
			}			
		</code>
	</pre>
</section>


<section>
	<h2>Destructuring Tuple</h2>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {

				let tup = (500, 6.4, 1);
			
				let (x, y, z) = tup;
			
				println!("The value of y is: {y}");
			}
					
		</code>
	</pre>
</section>

<section>
	<h2>The Array Type</h2>
	<ul>
		<li>Collection of multiple values is with an array</li>
		<li>Every element of an array must have the same type</li>
		<li>Arrays in Rust have a fixed length</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {

				let a = [1, 2, 3, 4, 5];

			}	
		</code>
	</pre>
	<p>Accessing Array Elements</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {

				let a = [1, 2, 3, 4, 5];
			
				let first = a[0];
				let second = a[1];
			}
		</code>
	</pre>
</section>

<section>
	<h2>Structure</h2>
	<ul>
		<li>Structs hold multiple related values</li>
		<li>In a struct you‚Äôll name each piece of data so it‚Äôs clear what the values mean</li>
		<li>Order of the data to specify or access the values of an instance need not be same</li>
	</ul>
</section>


<section>
	<h2>Defining a Struct</h2>
	<ul>
		<li>We enter the keyword 'struct' and name the entire struct</li>
		<li>Inside curly brackets, we define the names and types of the pieces of data, which we call <strong><em>'fields'</em></strong></li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			struct User {
				active: bool,
				username: String,
				email: String,
				sign_in_count: u64,
			}

			fn main() {}			
		</code>
	</pre>
</section>

<section>
	<h2>Instantiating a Struct</h2>
	<p>Create instance by stating the name of the struct and then add curly brackets containing <strong>key: value</strong> pairs</p>
	<ul>
		<li>keys are the names of the fields</li>
		<li>values are the data we want to store in those fields</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let user1 = User {
					active: true,
					username: String::from("someusername123"),
					email: String::from("someone@example.com"),
					sign_in_count: 1,
				};
			}
		</code>
	</pre>
</section>

<section>
	<h2>Enums</h2>
	<p>The enum keyword allows the creation of a type which may be one of a few different variants. Any variant which is valid as a struct is also valid as an enum</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			enum Work {
				Civilian,
				Soldier,
			}
			fn main() {
				use crate::Work::{Civilian, Soldier};
				// Equivalent to `Work::Civilian`.
				let work = Civilian;
				match work {
					// Note the lack of scoping because of the explicit `use` above
					Civilian => println!("Civilians work!"),
					Soldier  => println!("Soldiers fight!"),
				}
			}
		</code>
		<a href="https://codesandbox.io/p/sandbox/enum-4r0rw0">Run in online editor</a>
	</pre>
</section>

<section>
	<h1>Functions</h1>
</section>

<section>
	<h2>What we are covering</h2>
	<ul>
		<li>Define a function in rust</li>
		<li>Call a function in rust</li>
		<li>Function parameters</li>
		<li>Function with return value</li>
		<li>Memory management</li>
		<li>Generic parameters</li>
		<li>Associated functions</li>
		<li>Method that access data</li>
		<li>Generic types</li>
		<li>Closures</li>
	</ul>
</section>

<section>
	<h2>Define a Function in Rust</h2>
	<p>Function is a reusable block of code, in Rust <strong>"fn"</strong> keyword is used to define a function.</p>
	<pre data-id="code-animation">
		Structure: 
		<code class="hljs rust" data-trim data-line-numbers>
			//define a function

			fn function_name(arguments) -> return_val {
				// code
			}
		</code>
	</pre>
	<pre data-id="code-animation">
		Example:
		<code class="hljs rust" data-trim data-line-numbers>
			// greet function
			fn greet() {
				println!("Hello world!");
			}

			// main function
			fn main() {

			}
		</code>
	</pre>
</section>

<section>
	<h2>Calling a Function in Rust</h2>
	<p>Function name followed by parentheses "()" is used to call a function</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
    fn greet() {          <---------
                                    |
        println!("Hello world!");   | Execution flow is
    }                               | tranferred to
                                    | called function
    fn main() {                     |
        greet(); -------------------^
    }
		</code>
	</pre>
</section>

<section>
	<h2>Function Parameters</h2>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn multiply(num1: f64, num2: i64) {

				let result = num1 * num2 as f64;

				println!("Result: {}", result);
			}
		</code>
	</pre>
	<p>In this example function <strong>multiply</strong> accepts two parameters <em>'num1'</em> and <em>'num2'</em></p>
	<small>num1 has type f64, i.e float 64</small>
	</br>
	<small>num2 has type i64, i.e integer 64</small>
</section>

<section>
	<h2>Function with Return Value</h2>
	<ul>
		<li>`-> type` syntax is used to specify the return type</li>
		<li>possible to return a without explicitly using the `return` keyword</li>
		<li>the last expression is returned as the result of function</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn return_nothing() {
				// code
			}
			
			fn return_bool() -> bool {
				//code
				retun true;
			}

			fn multiply(float: f64, integer: i64) -> f64 {
				let result = float * integer as f64;
				result
			}
		</code>
	</pre>
</section>

<section>
	<h2>Generic Parameters</h2>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn min<T: PartialOrd>(a: T, b: T) -> T {
				if a < b {
					a
				} else {
					b
				}
			}

			fn main(){
				let x = min(5, 10);              // integer
				let y = min(5.0, 10.0);          // float
				let z = min("hello", "world");   // string
			}
		</code>
	</pre>
	<p><small>generic parameters allow a function, struct, or enum to work with multiple types, instead of just one specific type. You can specify generic parameters in a function signature by enclosing them in angle brackets (<  >) after the function name.</small></p>
</section>

<section>
	<h2>Associated Functions</h2>
	<ul>
		<li>function that belongs to a struct or enum, rather than an instance of that struct or enum</li>
		<li>Associated functions are called using the name of the struct or enum, followed by the double colon (::) operator</li>
	</ul>
	<pre data-id="code-animation">
		Example of an associated function `new` that acts as a constructor
		<code class="hljs rust" data-trim data-line-numbers>
			struct Point {
				x: i32,
				y: i32,
			}
			
			impl Point {
				fn new(x: i32, y: i32) -> Point {
					Point { x, y }
				}
			}
			fn main(){
				let p = Point::new(1, 2);
			}
		</code>
	</pre>
</section>

<section>
	<h2>Methods that access data</h2>
	<ul>
		<li>`new`: a constructor that creates a new instance of the Rectangle struct.</li>
		<li>`area`: a method that calculates the area of the Rectangle and uses `&self` to access the data</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			struct Rectangle {
				width: i32,
				height: i32,
			}
			
			impl Rectangle {
				fn new(width: i32, height: i32) -> Rectangle {
					Rectangle { width, height }
				}
				fn area(&self) -> i32 {
					self.width * self.height
				}
			}
			
		</code>
	</pre>
</section>

<section>
	<h2>Closures</h2>
	<p><small>a closure is an anonymous function that can capture values from the environment and defined using the `| |` characters.</small></p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn call_function< F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {
				f(x)
			}
			fn return_function() -> Box < dyn Fn(i32) -> i32> {
				Box::new(|x: i32| -> i32 { x * x })
			}
			fn main(){
				// Closure
				let square = |x: i32| -> i32 { x * x };
				// Closure can be passed as an argument to a function
				println!("The square of 2 is {}", call_function(square, 2));
				// Closure can be returned as a result from a function:
				let square = return_function();
				println!("The square of 2 is {}", square(2));
			}
		</code>
	</pre>
</section>

<section>
	<h1>Strings</h1>
</section>

<section>
	<h2>Strings</h2>
	<p>There are two types of strings in Rust</p>
	<ul>
		<li>String</li>
		<li>&str</li>
	</ul>
</section>

<section>
	<h2>String</h2>
	<ul>
		<li>Implemented as a smart pointer, specifically a Vec<u8>.</li>
		<li>Heap allocated, growable</li>
		<li>Can be mutated</li>
		<li>Always be a valid UTF-8, not null terminated sequence.</li>
	</ul>
	<!-- <pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			// creating a String using the String::new
			let s = String::new(); 
			//creating a String using the String::from function
			let s = String::from("hello"); 
			//converting a string slice &str to a String using the to_string method
			let s = "hello".to_string();
		</code>
	</pre> -->
</section>


<section>
	<h2>&str</h2>
	<ul>
		<li>An immutable reference to a valid UTF-8 sequence.</li>
		<li>May be anywhere, on the heap, stack, or in program memory.</li>
		<li>Only seen as a borrowed value.</li>
		<li>Has a fixed size, the value is known at compile time</li>
	</ul>
	<!-- <pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			//creating an &str from a string literal
			let s = "hello";
			//creating an &str from a String:
			let s = String::from("hello");
			let str_slice = &s[0..2];
		</code>
	</pre> -->
</section>

<section>
	<h2>Initialization</h2>
	<p>String</p>
	<pre data-id="code-animation">
		
		<code class="hljs rust" data-trim data-line-numbers>
			// creating a String using the String::new
			let s = String::new(); 

			//creating a String using the String::from function
			let s = String::from("hello"); 

			//converting a string slice &str to a String using the to_string method
			let s = "hello".to_string();
		</code>
		Use `String` when you need to modify or own a string
	</pre>
	<p>&str</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			//creating an &str from a string literal
			let s = "hello";

			//creating an &str from a String:
			let s = String::from("hello");
			let str_slice = &s[0..2];
		</code>
		Use `&str` when you just want to borrow a reference to a string
	</pre>
</section>

<section>
	<h2>Initialization</h2>
	<img data-src="images/strings_memory_allocation.png">
</section>

<section>
	<h2>Operations on Strings</h2>
	<small>concatenation | appending | slicing | splitting | replacing | iterating | checking starts prefix | checkin ends suffix</small>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			let s1 = String::from("hello world");
			let mut s2 = String::from("rust is awesome");

			let s3 = s1 + &s2;             // Concat using the `+` operator
			let s4 = format!("{}{}",s1,s2);// Concat using the format! macro
			s2.push_str(", & memory safe");// Appending using the push_str
			let slice = &s[0..2];          // Slicing using string indices

			for c in "hello".chars() {     // Iterating over the string
				println!("{}", c);
			}
			println!("Length:{}", s.len());// Finding the length of a string
			if(s1.starts_with("he")){}     // Check if starts with a prefix
			if(s1.ends_with("ld")){}       // Check if ends with a suffix
		</code>
	</pre>
</section>

<section>
	<h1>Memory management</h1>
</section>

<section>
	<h2>Memory management</h2>
	<p>Rust program process is allocated some virtual memory by the Operating System(OS), this is the total memory that the process has access.</p>
	<img data-src="images/memory_structure.png">
</section>

<section>
	<h2>Heap Memory</h2>
	<ul>
		<li>This is where all dynamic data(any data for which size cannot be calculated at compile time) is stored.</li>
		<li>This is the biggest block of memory and the part managed by Rust‚Äôs Ownership model.</li>
		<li><strong>Box:</strong> The <a href="https://doc.rust-lang.org/stable/rust-by-example/std/box.html">Box type</a> is an abstraction for a heap-allocated value in Rust.</li>
		<li>Heap memory is allocated when Box::new is called. A Box < T > holds the smart-pointer to the heap memory allocated for type T and the reference is saved on the Stack.</li>
	</ul>
</section>

<section>
	<h2>Stack Memory</h2>
	<ul>
		<li>This is the Stack memory area and there is one Stack per thread.</li>
		<li>This is where static values are allocated by default. </li>
		<li>Static data(data size known at compile time) includes function frames, primitive values, Structs and pointers to dynamic data in Heap</li>
	</ul>
</section>

<section>
	<h2>Memory Usage</h2>
	<p>All values in Rust are allocated on the Stack by default. There are two exceptions to this</p>
	<ol>
		<li>When size of the value is dynamic like String/Vectors</li>
		<li>When you manually create a Box < T > value which is allocated on heap</li>
	</ol>
	<p>In both exception cases, the value will be allocated on Heap and its pointer will live on the Stack.</p>
</section>


<section>
	<p>
		<img data-src="images/memory_usage_1.png" onclick="ChangeTransitionToFade();"></a>
	</p>
</section>

<section data-markdown>
	<script type="text/template">
		![](images/memory_usage_2.png)

		---

		![](images/memory_usage_3.png)

		---

		![](images/memory_usage_4.png)

		---

		![](images/memory_usage_5.png)

		---

		![](images/memory_usage_6.png)

		---

		![](images/memory_usage_7.png)

		---

		![](images/memory_usage_8.png)

		---

		![](images/memory_usage_9.png)

		---

		![](images/memory_usage_10.png)

		---

		![](images/memory_usage_11.png)

		---

		![](images/memory_usage_12.png)
	</script>
</section>

<section>
	<p>
		<img data-src="images/memory_usage_13.png" onclick="ChangeTransitionToSlide();"></a>
	</p>
</section>

<section>
	<h2>Smart Pointers</h2>
	<ul>
		<li>A pointer is a general concept for a variable that contains an address in memory.</li>
		<li>Smart pointers implement the Deref and Drop traits.</li>
		<ul>
			<li>The Deref trait allows an instance of the smart pointer struct to behave like a reference so you can write your code to work with either references or smart pointers.</li>
			<li>The Drop trait allows you to customize the code that‚Äôs run when an instance of the smart pointer goes out of scope.</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Smart pointers in the standard library</h3>
	<ul>
		<li>Box< T > for allocating values on the heap</li>
		<li>Rc< T >, a reference counting type that enables multiple ownership</li>
		<li>Ref< T > and RefMut< T >, accessed through RefCell< T >, a type that enforces the borrowing rules at runtime instead of compile time</li>
	</ul>
</section>

<section>
	<h3>Box< T ></h3>
	<ul>
		<li>Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data.</li>
		<li>Box< T > allows immutable or mutable borrows checked at compile time</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let b = Box::new(5);
				println!("b = {}", b);
			}			
		</code>
	</pre>
</section>

<section>
	<h3>Rc< T ></h3>
	<small>
		<ul>
			<li>To enable multiple ownership explicitly by using the Rust type Rc<T>, which is an abbreviation for reference counting.</li>
			<li>The Rc<T> type keeps track of the number of references to a value to determine whether or not the value is still in use</li>
			<li>If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</li>
			<li>Rc<T> allows only immutable borrows checked at compile time</li>
		</ul>
	</small>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			// code here
		</code>
	</pre>
</section>

<section>
	<h3>RefCell< T ></h3>
	<small>
		<ul>
			<li>Rc< T >, the RefCell< T > type represents single ownership over the data it holds.</li>
			<li>At any given time, you can have either (but not both) one mutable reference or any number of immutable references.</li>
			<li>Rc< T > enables multiple owners of the same data; Box< T > and RefCell< T > have single owners.</li>
			<li>RefCell< T > allows immutable or mutable borrows checked at runtime.</li>
		</ul>
	</small>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			// code here
		</code>
	</pre>
</section>

<section>
	<h1>Control Flow</h1>
</section>

<section>
	<h3>if expression</h3>
	<ul>
		<li>The most common way to introduce control flow and branch code.</li>
		<li>Provide a condition and then execute the block of code if the condition is met.</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let price: i32 = 10;
				if price > 0 {
				   println!(‚Äútrue‚Äù);
				}
			}			 
		</code>
	</pre>
</section>

<section>
	<h3>if-else expression</h3>
	<ul>
		<li>An else expression can be added optionally.</li>
		<li>If no else is provided the program will skip the if block if the condition is false.</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let price: i32 = 10;
				if price > 0 {
				  println!(‚Äútrue‚Äù);
				}
				else {
				  println!(‚Äúfalse‚Äù);
				}
			}						  
		</code>
	</pre>
</section>

<section>
	<h3>else-if expression</h3>
	<ul>
		<li>If you have more than two condition to check, if and else can be combined in else if expression.</li>
		<li>In the case all if and else if conditions evaluates to false, then the else block is executed.</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let price: i32 = 10;
				if price == 1 {
				  println!(‚Äúprice is 1.‚Äù);
					}
				else if price = 2 {
				  println!(‚Äúprice is 2.‚Äù);
				}
				else {
				  println!(‚Äúother price‚Äù);
				}
			}							   
		</code>
	</pre>
</section>


<section>
	<h3>match</h3>
	<ul>
		<li>Rust provides pattern matching with the match keyword</li>
		<li>A scrutinee expression is provided to compare to the patterns.</li>
		<li>Arms are evaluated and compared with the scrutineer expression</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let x = 1;
				match x {
				  1 => println!(‚Äúone‚Äù),
				  2 => println!(‚Äútwo‚Äù),
				  3 => println!(‚Äúthree‚Äù),
				  4 => println!(‚Äúfour‚Äù),
				  5 => println!(‚Äúfive‚Äù),
				  _ => println!(‚Äúsomething else‚Äù),
				}
			}									
		</code>
	</pre>
</section>

<section>
	<h3>match</h3>
	<ul>
		<li>Here the scrutineer expression is x.</li>
		<li>Each arm has a pattern and some code. The ‚Äú=>‚Äù operator separates the pattern and the code to run.</li>
		<li>The first arm with the matching pattern is chosen as the branch target of the match.</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let x = 1;
				match x {
				  1 => println!(‚Äúone‚Äù),
				  2 => println!(‚Äútwo‚Äù),
				  3 => println!(‚Äúthree‚Äù),
				  4 => println!(‚Äúfour‚Äù),
				  5 => println!(‚Äúfive‚Äù),
				  _ => println!(‚Äúsomething else‚Äù),
				}
			}							 
		</code>
		<a href="https://codesandbox.io/p/sandbox/flow-control-forked-fu4iwj?file=%2Fsrc%2Fmain.rs">Run in online editor</a>
	</pre>
</section>

<section>
	<h3>loop</h3>
	<ul>
		<li>Used to execute over block of code forever, Or until it is stopped, or the program quits.</li>
		<li>Instead of having this loop infinitely the break keyword can be used.</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() { 
				let mut i = 0; 
			  
				loop { 
				  i += 1; 
			  
				  if i > 100 { break; } 
				}
			} 								
		</code>
	</pre>
</section>


<section>
	<h3>while</h3>
	<ul>
		<li>Conditional loops</li>
		<li>Run until the condition is met or become false</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let mut num = 3;
				while num !=0 {
				  println!(‚Äú{}‚Äù, num);
				  num -= 1;
				}
				println!(‚ÄúLIFTOFF!!‚Äù); 
			}						 
		</code>
	</pre>
</section>

<section>
	<h3>for loop</h3>
	<ul>
		<li>Iterate over a element in a collection</li>
		<li>Each pass of the loop extracts values</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let a = [10, 20, 30, 40, 50];
				for element in a.iter() {
				  println!(‚Äúthe value is {}‚Äù, element);
				} 
			}				  
		</code>
	</pre>
</section>

<section>
	<h3>iterators</h3>
	<ul>
		<li>In Rust, iterators help us achieve the process of looping.</li>
		<li>Using the <strong><em>iter()</em></strong> function, we tell Rust that the given array can be used with a loop.</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let a = [10, 20, 30, 40, 50];
				for element in a.iter() {
				  println!(‚Äúthe value is {}‚Äù, element);
				} 
			}				   
		</code>
	</pre>
</section>

<section>
	<h3>iterator trait</h3>
	<ul>
		<li>In Rust, all iterators implement a trait named ‚Äúiterator‚Äù that has a method called <strong><em>next()</em></strong></li>
		<li>Using the <strong><em>iter()</em></strong> function, we tell Rust that the given array can be used with a loop.</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let a = [10, 20, 30, 40, 50];
				for element in a.iter() {
				  println!(‚Äúthe value is {}‚Äù, element);
				} 
			}				   
		</code>
	</pre>
	<p>Any data type which implements <strong><em>next()</em></strong> method can be iterator.</p>
</section>

<section>
	<p>Difference in into_iter, iter, iter_mut.</p>
	<ul>
		<li><strong><em>into_iter:</em></strong> Consumes the collection, once the collection has been consumed, it is no longer available for reuse.</li>
		<li><strong><em>iter:</em></strong> This borrows each element of the collection through each iteration, thus leaving the collection untouched and available for reuse after the loop</li>
		<li><strong><em>iter_mut:</em></strong> This mutably borrows each element of the collection, allowing for the collection to be modified in place.</li>
	</ul>
</section>

<section>
	<p>Creating our own iterator</p>
	<p>Excercise:</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			struct Counter {
				count: u32,
			}
			impl Counter {
				fn new() -> Counter {
					Counter { count: 0 }
				}
			}
			impl Iterator for Counter {
				type Item = u32;
				fn next(&mut self) -> Option< Self::Item> {
					if self.count < 5 {
						self.count += 1;
						Some(self.count)
					} else {
						None
					}
				}
			}
			fn main() {
				let mut counter = Counter::new();
				assert_eq!(counter.next(), Some(1));
				assert_eq!(counter.next(), Some(2));
				assert_eq!(counter.next(), Some(3));
				assert_eq!(counter.next(), Some(4));
				assert_eq!(counter.next(), Some(5));
				assert_eq!(counter.next(), None);
			}				   
		</code>
		<a href="https://codesandbox.io/p/sandbox/iterator-forked-2pxyb0?file=%2Fsrc%2Fmain.rs">Run in online editor</a>
	</pre>
</section>

<section>
	<h1>Rust's Ownership & Borrowing</h1>
</section>

<section>
	<h3>Ownership</h3>
	<ul>
		<li>The ‚Äúowner‚Äù can change the owning value according to mutability.</li>
		<li>Ownership can transfer to an other variable.</li>
		<li>Ownership model guarantees the safeness.</li>
	</ul>
</section>

<section>
	<h3>Ownership rules</h3>
	<p>Each value in Rust has an <strong><em>owner</em></strong></p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main () {
				let vector1 = vec![1, 2, 3];
			  }			   
		</code>
	</pre>
	<p>Here `vector1` is <strong><em>owner</em></strong></p>
</section>


			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>

			let ChangeTransitionToFade = function(){
				console.log("Change-Transition-to-Fade");
				window.location = "?transition=fade#/51";
			}
			let ChangeTransitionToSlide = function(){
				console.log("Change-Transition-to-Slide");
				window.location = "?transition=slide#/63";
			}
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/			
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
			// document.getElementById('theme').setAttribute('href','dist/theme/night.css');
		</script>
	</body>
</html>
