<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>rust-fundamentals</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/night.css">
		<link rel="stylesheet" href="css/style.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
	<div id="EditorDiv" hidden>
		<!-- <button onclick="CloseEditor()">Back to Presentation</button> -->
		<iframe
			id="EditorFrame"
			style="width:100%; height:780px; border:0; border-radius: 4px; overflow:hidden; align-items: center; margin-top: 70px;"
			sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts allow-pointer-lock allow-top-navigation allow-orientation-lock"
		></iframe>
		<!-- <embed src="https://codesandbox.io/embed/new?codemirror=1"
		id="EditorFrame"
		width=1200
		height=800
		onerror="alert('URL invalid !!');" /> -->
	</div>
<div class="reveal">

	<div id="static-elements">
		<div class="header-left">
			<!-- <img src="images/rust_logo.png"></img> -->
		</div>
		<div class="header-right">
			<a href="#/1"><img src="images/rustacean.png"></img></a>
		</div>
		
		<div class="header-center">
			<!-- <div class="slide-chapter"></div> -->
			<button id="BackToPresentation" class="BackBtn" onclick="CloseEditor()"><< Back to Presentation</button>
		</div>
		<div class="footer-center">
			<!-- <div class="slide-title">test</div> -->
		</div>

		<div class="footer-left">
			<footnote><text id="slide-number"></text></footnote>
		</div>

		<!-- <div class="footer-right">
		</div> -->
	</div>



	<div class="slides" id="SlidesDiv">
<!----------------------------------------------------------------------------+
|        ************* CODE FOR SLIDES DECK STARTS HERE  *************        |
+----------------------------------------------------------------------------->


<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section class="r-fit-text">
	<img src="images/rust_logo.png" style="height: 100px;"></img>
	<h2>Rust Fundamentals</h2>
	<small>Bosch Cybersecurity University</small>
</section>


<!----------------------------------------------------------------------------+
|  Topics: List of topics being covered in this presentation                  |
+----------------------------------------------------------------------------->
<section>
	<h3>Topics</h3>
	<ul style="font-size: 28px;">
		<li><a href="#/2">Basics of Rust</a></li>
		<li><a href="#/6">Data types</a></li>
		<li><a href="#/32">Functions</a></li>
		<li><a href="#/47">Strings</a></li>
		<li><a href="#/55">Ownership</a></li>
		<li><a href="#/62">Traits</a></li>
		<li><a href="#/70">Lifetimes</a></li>
		<li><a href="#/71">Visibility Modifiers</a></li>
		<li><a href="#/72">Memory Management</a></li>
		<li><a href="#/98">Control Flow</a></li>
		<li><a href="#/111">Error Handling</a></li>
		<li><a href="#/123">Concurrency</a></li>
		<li><a href="#/131">Async and Await</a></li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
| Title Slide for topic: Basics of Rust                                       |
+----------------------------------------------------------------------------->
<section>
	<h1>Basics of Rust</h1>
</section>

<!----------------------------------------------------------------------------+
| Slide explaining steps for getting started with rust installation           |
+----------------------------------------------------------------------------->
<section>
	<h2>Getting Started</h2>
	<ol>
		<li>
			How to install rust.
			<p>
				<a href="https://www.rust-lang.org/learn/get-started" target="_blank">https://www.rust-lang.org/learn/get-started</a>
			</p>
		</li>
		<li>
			Rust tools.
			<ul>
				<li><a href="https://rustup.rs/" target="_blank">rustup</a></li>
				<li>cargo</li>
				<li>rustc</a></li>
				<li><a href="https://crates.io/" target="_blank">crates.io</a></li>
			</ul>
		</li>
		<li>
			<a href="https://codesandbox.io/p/sandbox/basics-of-rust-kbv4b4" target="_blank">Rust Project Structure</a>
		</li>
	</ol>
</section>

<!----------------------------------------------------------------------------+
| Compilation Process                                                         |
+----------------------------------------------------------------------------->
<section>
	<h4>Compilation Process in C/C++</h4>
	<a style="font-size: 22px;" href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials/blob/master/03_hacky_hello_world/Makefile" target="_blank">Makefile</a>
	<br>
	<img src="images/cBuild.png" height="440px"></img>
</section>


<section>
	<h4>Compilation Process in Rust</h4>
	<a style="font-size: 22px;" href="https://github.com/nihalpasham/rustBoot/blob/main/boards/bootloaders/stm32f334/Cargo.toml" target="_blank">TOML file</a>
	<br>
	<img src="images/rust-project-folder-structure.png" height="440px"></img>
	<br>
	
</section>


<!----------------------------------------------------------------------------+
| Title Slide for topic: Data Types                                           |
+----------------------------------------------------------------------------->
<section>
	<h1>Data Types</h1>
</section>


<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3><a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html" target="_blank">Variables and Mutability</a></h3>

	<p>Variables are immutable by default</p>

	<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
		fn main() {
			let x = 5;
			println!("The value of x is: {x}");
			x = 6;
			println!("The value of x is: {x}");
		}		
	</code></pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Variables and Mutability</h3>
	<pre data-id="code-animation">
		<p style="font-size: 36px;">Error message displayed:</p>
		<code class="hljs rust" data-trim data-line-numbers>
		$ cargo run
		Compiling variables v0.1.0 (file:///projects/variables)
		error[E0384]: cannot assign twice to immutable variable `x`
			--> src/main.rs:4:5
		2  |     let x = 5;
		   |         -
		   |         |
		   |         first assignment to `x`
		   |         help: consider making this binding mutable: `mut x`
		3  |     println!("The value of x is: {x}");
		4  |     x = 6;
		   |     ^^^^^ cannot assign twice to immutable variable
		For more information about this error, try `rustc --explain E0384`.
		error: could not compile `variables` due to previous error
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2 data-id="code-title">Mutability</h2>
	<p>To fix the error add <strong>`<a href="https://doc.rust-lang.org/std/keyword.mut.html" target="_blank">mut</a>`</strong> keyword before variable name.</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let mut x = 5;
				println!("The value of x is: {x}");
				x = 6;
				println!("The value of x is: {x}");
			}			
		</code>
	</pre>
	<pre data-id="code-animation">
		Output:
		<code class="hljs rust" data-trim data-line-numbers>
			$ cargo run
			Compiling variables v0.1.0 (file:///projects/variables)
			 Finished dev [unoptimized + debuginfo] target(s) in 0.30s
			  Running `target/debug/variables`
		 The value of x is: 5
		 The value of x is: 6		 
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Constants</h2>
	<ul>
		<li><a>Constants</a> are values that are bound to a name and are <a>not allowed to change</a></li>
		<li><strong>`<a href="https://doc.rust-lang.org/std/keyword.const.html" target="_blank">const</a>`</strong> keyword is used to declare constants instead of the `let` keyword, and the type of the value must be annotated</li>
		<li><strong>`mut`</strong> is not used with <strong>`const`</strong></li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Constants</h2>
	<ul style="font-size: 31px;">
		<li>Constants can be <a>declared in any scope</a>, including the global scope</li>
		<li>Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime</li>
	</ul>
	<pre data-id="code-animation" style="font-size: 19px;">
		<code class="hljs rust" data-trim data-line-numbers>
			struct Circle {
				radius: f64,
			}

			impl Circle {
				const PI: f64 = 3.14159;
			
				fn new(radius: f64) -> Circle {
					Circle { radius }
				}
				fn calculate_area(&self) -> f64 {
					Circle::PI * self.radius * self.radius
				}
			}		 
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Shadowing</h3>
	<ul style="font-size: 38px;">
		<li>You can declare a new variable with the same name as a previous variable</li>
		<li>The first variable is shadowed by the second</li>
	</ul>
	<pre data-id="code-animation">
		<code style="font-size: 18px;" class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let x = 5;
				let x = x + 1;
				{
					let x = x * 2;
					println!("The value of x in the inner scope is: {x}");
				}
				println!("The value of x is: {x}");
			}
		</code>
	</pre>
</section>

<section>
	<h3>Shadowing</h3>
	<pre data-id="code-animation">
		<p style="font-size: 36px;">Output:</p>
		<code class="hljs rust" data-trim data-line-numbers>
			$ cargo run
			Compiling test-rust v0.1.0 (file:///projects/shadowing)
			Finished dev [unoptimized + debuginfo] target(s) in 3.20s
			Running `target/debug/test-rust`

			The value of x in the inner scope is: 12
			The value of x is: 6
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#data-types" target="_blank">Data Types</a></h2>
	<ul>
		<li>Data type subsets: <em><a>scalar</a></em> and <em><a>compound</a></em></li>
		<li>Rust is a <a>statically typed</a> language, which means that it <a>must know the types</a> of all variables at <a>compile time</a></li>
		<li><a>Data Structures</a></li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#scalar-types" target="_blank">Scalar Types</a></h2>
	<ul>
		<p>A scalar type represents a single value</p>
		<ul>
			<li>Integers</li>
			<li>Floating-point numbers</li>
			<li>Booleans</li>
			<li>Characters</li>
		</ul>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Integer Types</h3>
	<p>An integer is a number without a fractional component</p>
	<table style="font-size: 34px;">
		<thead>
			<tr>
				<th>Number literals</th>
				<th>Example</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>Decimal</td>
				<td>98_222</td>
			</tr>
			<tr>
				<td>Hex</td>
				<td>0xff</td>
			</tr>
			<tr>
				<td>Octal</td>
				<td>0o77</td>
			</tr>
			<tr>
				<td>Binary</td>
				<td>0b1111_0000</td>
			</tr>
			<tr>
				<td>Byte (u8 only)</td>
				<td>b'A'</td>
			</tr>
		</tbody>
	</table>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Floating-Point Types</h2>
	<ul>
		<li>Numbers with decimal points</li>
		<li>Rust’s floating-point types are <a>f32</a> and <a>f64</a></li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
		fn main() {
			let x = 2.0;        // f64 (default)
			let y: f32 = 3.0;   // f32
		}					 
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Numeric Operations</h2>
	<pre data-id="code-animation" style="height: 500px;">
		<code class="hljs rust" data-trim data-line-numbers>
		fn main() {

			// addition
			let sum = 5 + 10;            

			// subtraction
			let difference = 95.5 - 4.3; 

			// multiplication
			let product = 4 * 30;       

			// division
			let quotient = 56.7 / 32.2;  
			let truncated = -5 / 3;      // Results in -1

			// remainder
			let remainder = 43 % 5;      
		}								 
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>The Boolean Type</h2>
	<ul>
		<li>Rust has two possible values: <a>true</a> and <a>false</a></li>
		<li>Booleans are <a>one byte in size</a></li>
		<li>It is specified using `<a href="https://doc.rust-lang.org/std/primitive.bool.html" target="_blank">bool</a>`</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {

				let t = true;
			
				let f: bool = false; // with explicit type annotation
			}								 
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>The Character Type</h2>
	<ul>
		<li>Rust’s <strong>`<a href="https://doc.rust-lang.org/std/primitive.char.html" target="_blank">char</a>`</strong> type is the language’s most primitive alphabetic type</li>
		<li>Specify `char` literals with single quotes <a>' '</a></li>
		<li>Rust’s `char` type is <a>four bytes in size</a> and represents a <a>unicode</a> Scalar Value, which means it can represent a lot more than just ASCII</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let c = 'z';
				let z: char = 'ℤ';         // with explicit type annotation
				let heart_eyed_cat = '😻'; //emoji
			}					 
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Compound Types</h2>
	<ul>
		<li>Compound types can group multiple values into one type</li>
		<li>Rust has two primitive compound types: <strong><a href="https://doc.rust-lang.org/std/primitive.tuple.html" target="_blank">tuples</a></strong> and <strong><a href="https://doc.rust-lang.org/std/primitive.array.html" target="_blank">arrays</a></strong></li>
	</ul>
</section>


<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>The Tuple Type</h3>
	<ul style="font-size: 38px;">
		<li>A tuple is a general way of <a>grouping</a> together a <a>different types</a> into one compound type</li>
		<ul style="font-size: 38px;">
			<li>Fixed length</li>
			<li>Known at Compile time</li>
			<li>Heterogeneous</li>
		</ul>
	</ul>
	<pre data-id="code-animation" style="font-size: 16px;">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				// creating tuple
				let tup: (i32, f64, u8) = (500, 6.4, 1);
				let gfg: (&str, &str, &str) = ("Apple", "For", "Bananas");

				// accessing tuple data using positional argument
				println!("{} {} {}", gfg.0, gfg.1, gfg.2);

				// creating another tuple
				let article = ("abc", "xyz", 14,12,2020);
				let (a,b,c,d,e) = article;

				// accessing tuple using variables
				println!("This written by {} at {} on {}/{}/{}", b,a,c,d,e);
			}			
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Destructuring Tuple</h2>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {

				let tup = (500, 6.4, 1);
			
				let (x, y, z) = tup;
			
				println!("The value of y is: {y}");
			}
					
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>The Array Type</h2>
	<ul>
		<li><a>Collection of</a>  multiple values is with an array</li>
		<li>Every element of an array must have the <a>same type</a></li>
		<li>Arrays in Rust have a <a>fixed length</a></li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let a = [1, 2, 3, 4, 5];
			}	
		</code>
	</pre>
	<p>Accessing Array Elements</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let a = [1, 2, 3, 4, 5];
				let first = a[0];
				let second = a[1];
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Compound Types</h2>
	<p><strong>Exercise-1</strong></p>
	<!-- <p><small>(clue: all the array elements should be of same type)</small></p> -->
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let _arr = [1, 2, '3'];
				println!("Success!");
			}							 
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/rusttrainingexamples-forked-lzz4h8?file=%2Fexamples%2Ftypeerror.rs')"> in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/rusttrainingexamples-forked-lzz4h8?file=%2Fexamples%2Ftypeerror.rs')"> in online editor</p> -->
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Compound Types</h2>
	<p><strong>Exercise-2</strong></p>
	<!-- <p><small>(clue: indexing should start from 0)</small></p> -->
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let arr = ['a', 'b', 'c'];
				let ele = arr[1];
				assert!(ele == 'a');
				println!("Success!");
			}
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/elegant-curie-w3wxp4?file=%2Fexamples%2Farrayindexing.rs')"> in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/elegant-curie-w3wxp4?file=%2Fexamples%2Farrayindexing.rs')"> in online editor</p> -->
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Data Structure</h2>
	<ul>
		<li>Structs hold multiple related values</li>
		<li>In a struct you’ll name each piece of data so it’s clear what the values mean</li>
		<li>Order of the data to specify or access the values of an instance need not be same</li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Defining a Struct</h2>
	<ul>
		<li>The <strong>`<a href="https://doc.rust-lang.org/std/keyword.struct.html" target="_blank">struct</a>`</strong> keyword is used to declare a structure followed by the name</li>
		<li>Inside curly brackets, we define the names and types of the pieces of data, which we call <strong>'fields'</strong></li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			struct User {
				active: bool,
				username: String,
				email: String,
				sign_in_count: u64,
			}

			fn main() {}			
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Instantiating a Struct</h2>
	<p>Create instance by stating the name of the `struct` and then add curly brackets {} containing <strong>'key:value'</strong> pairs</p>
	<ul>
		<li>keys are the names of the fields</li>
		<li>values are the data stored in those fields</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
		fn main() {
		    let user1 = User {
		        active  : true,
		        username: String::from("someusername123"),
		        email   : String::from("someone@example.com"),
		        count   : 1,
		    };
		}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Tuple structs</h2>
	<ul style="font-size: 36px;">
		<li><a>'tuple struct'</a> is a hybrid between tuple and struct</li>
		<li>Tuple structs have a name, but their fields don't</li>
		<li>Declared with <a>struct</a> keyword, and then with a name followed by tuple </li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			struct Person(String, u32);
			fn main() {
				// Create a new instance of the 'Person' tuple struct
				let person1 = Person(String::from("Alice"), 30);
				let person2 = Person(String::from("Bob"), 25);
			
				// Access the fields of the tuple struct using dot notation
				println!("{} is {} years old.", person1.0, person1.1);
				println!("{} is {} years old.", person2.0, person2.1);
			}
		</code>
	</pre>

</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Enums</h2>
	<ul style="font-size: 34px;">
		<li>The <strong>`<a href="https://doc.rust-lang.org/std/keyword.enum.html" target="_blank">enum</a>`</strong> keyword allows the creation of a type which may be <a>one of a few different variants</a></li>
		<li>Any variant which is valid as a struct is also valid as an enum</li>
	</ul>
	<pre data-id="code-animation" style="font-size: 16px;">
		<code class="hljs rust" data-trim data-line-numbers>
			enum Work {
				Civilian,
				Soldier,
			}
			fn main() {
				use crate::Work::{Civilian, Soldier};
				// Equivalent to `Work::Civilian`.
				let work = Civilian;
				match work {
					// Note the lack of scoping because of the explicit `use` above
					Civilian => println!("Civilians work!"),
					Soldier  => println!("Soldiers fight!"),
				}
			}
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/enum-4r0rw0?file=%2Fexamples%2Fenum1.rs')"> in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/enum-4r0rw0?file=%2Fexamples%2Fenum1.rs')"> in online editor</p> -->
	</pre>
</section>

<!----------------------------------------------------------------------------+
| Title Slide for topic: Functions in rust                                    |
+----------------------------------------------------------------------------->
<section>
	<h1>Functions</h1>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>What we are covering</h3>
	<ul style="font-size: 33px;">
		<li>Define a Function in Rust</li>
		<li>Calling a Function in Rust</li>
		<li>Function Parameters</li>
		<li>Function with Return Value</li>
		<li>Traits</li>
		<li>Memory Management</li>
		<li>Generic Functions</li>
		<li>Associated Functions</li>
		<li>Method that Access Data</li>
		<li>Generic Types</li>
		<li>Closures</li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Define a Function in Rust</h3>
	<p>Function is a <a>reusable</a> block of code, in Rust <strong>`<a href="https://doc.rust-lang.org/std/keyword.fn.html" target="_blank">fn</a>`</strong> keyword is used to define a function</p>
	<pre data-id="code-animation"> 
		<code class="hljs rust" data-trim data-line-numbers>
			//define a function
			fn function_name(arguments) -> return_type {
				// code
			}
		</code>
	</pre>
	<pre data-id="code-animation" style="font-size: 20px;">
		Example:
		<code class="hljs rust" data-trim data-line-numbers>
			// greet function
			fn greet() {
				println!("Hello world!");
			}

			// main function
			fn main() {
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Calling a Function in Rust</h3>
	<p>Function name followed by parentheses "()" is used to call a function</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
    fn greet() {          <---------
                                    |
        println!("Hello world!");   | Execution flow is
    }                               | tranferred to
                                    | called function
    fn main() {                     |
        greet(); -------------------^
    }
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/05lq3j?file=%2Fsrc%2Fmain.rs')"> in online editor</p> -->
	</pre>
	
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Function Parameters</h2>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn multiply(num1: f64, num2: i64) {

				let result = num1 * num2 as f64;

				println!("Result: {}", result);
			}
		</code>
	</pre>
	<p>In this example function <strong>multiply</strong> accepts two parameters:</p>
	<ol style="font-size: 36px;">
		<li>'num1' - which has type f64 i.e. float 64</li>
		<li>'num2' - which has type i64 i.e. integer 64</li>
	</ol>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Function with Return Value</h3>
	<ul style="font-size: 38px;">
		<li>`<a><strong>-></strong></a>` syntax is used to specify the return type</li>
		<li>possible to return a <a>without</a> explicitly using the `<a href="https://doc.rust-lang.org/std/keyword.return.html" target="_blank"><strong>return</strong></a>` keyword</li>
		<li>the <a>last expression</a> is returned as the result of function</li>
	</ul>
	<pre data-id="code-animation" style="font-size: 19px;">
		<code class="hljs rust" data-trim data-line-numbers>
			fn return_nothing() {
				// code
			}
			
			fn return_bool() -> bool {
				//code
				return true;
			}

			fn multiply(float: f64, integer: i64) -> f64 {
				let result = float * integer as f64;
				result
			}
		</code>
	</pre>
</section>

<section>
	<h3><a href="https://doc.rust-lang.org/std/keyword.trait.html" target="_blank">Traits</a></h3>
	<ul>
		<li><strong><em>'Traits'</em></strong> are the abstract mechanism for adding functionality to types or it tells <em>Rust compiler</em> about functionality a type <strong><a>must</a></strong> provide</li>
		<li><strong><em>'Traits'</em></strong></a> are a way to group methods to define a set of <strong><a>behavior</a></strong> necessary to accomplish some purpose</li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Trait Definition</h3>
	<ul>
		<li>Traits are defined by the <strong>`<a href="https://doc.rust-lang.org/std/keyword.trait.html" target="_blank">trait</a>`</strong> keyword followed by the name of the trait</li>
		<li>While defining any trait we have to provide method signatures (method declaration)</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			pub trait Calculator {
				fn add(&self) -> i32;
				fn sub(&self) -> i32;
				fn div(&self) -> i32;
				fn mul(&self) -> i32;
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Trait implementation</h3>
	<ul>
		<li><strong>`<a href="https://doc.rust-lang.org/std/keyword.impl.html" target="_blank">impl</a>`</strong> keyword used to implement a trait</li>
		<li><strong>`<a href="https://doc.rust-lang.org/std/keyword.for.html" target="_blank">for</a>`</strong> is used when implementing traits as in impl Trait for Type</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			impl trait_name for type_name {
				
				//method definitions
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<p><strong style="font-size: 22px;">Example</strong></p>
	<pre data-id="code-animation" style="width: 800px; height: 420px; font-size: 14px;">
		<code class="hljs rust" data-trim data-line-numbers>
			struct Calc {
				first_num: i32,
				second_num: i32
			}
			impl Calculator for Calc {
				fn add(&self) -> i32 {
					self.first_num + self.second_num
				}
				fn sub(&self) -> i32 {
					self.first_num - self.second_num
				}
				fn div(&self) -> i32 {
					self.first_num / self.second_num
				}
				fn mul(&self) -> i32 {
					self.first_num * self.second_num
				}
			}
			fn main() {
				println!("Output of Add: {}", Calc {first_num:2, second_num: 2}.add());
				println!("Output of Sub: {}", Calc {first_num:4, second_num: 2}.sub());
				println!("Output of Div: {}", Calc {first_num:10, second_num: 2}.div());
				println!("Output of Mul: {}", Calc {first_num:2, second_num: 2}.mul());
			}
		</code>
	</pre>
	<pre data-id="code-animation" style="width: 800px; font-size: 15px;">
		Output: 
		<code class="hljs rust" data-trim data-line-numbers>
		Compiling playground v0.0.1 (/playground)
		Finished dev [unoptimized + debuginfo] target(s) in 0.59s
			Running `target/debug/playground`

		Output of Add: 4
		Output of Sub: 2
		Output of Div: 5
		Output of Mul: 4
		</code>
	</pre>
</section>


<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h4>Generic Functions</h4>
	<p style="font-size: 30px;">Generic parameters allow a function, struct, or enum to work with multiple types, instead of just one specific type. You can specify generic parameters in a function signature by enclosing them in angle brackets (< >) after the function name.</p>
	<pre data-id="code-animation" style="font-size: 18px;">
		Example using <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html" target="_blank">PartialOrd</a> trait
		<code class="hljs rust" data-trim data-line-numbers>
			fn min< T:PartialOrd > (a: T, b: T) -> T {
				if a < b {
					a
				} else {
					b
				}
			}
			fn main(){
				let x = min(5, 10);              // integer
				let y = min(5.0, 10.0);          // float
				let z = min("hello", "world");   // string
				println!("x: {x}");
				println!("y: {y}");
				println!("z: {z}");
			}
		</code>
		<a href="https://doc.rust-lang.org/std/primitive.i32.html" target="_blank">i32</a> | <a href="https://doc.rust-lang.org/std/primitive.f64.html" target="_blank">f64</a> | <a href="https://doc.rust-lang.org/std/string/struct.String.html" target="_blank">string</a>

	</pre>
	
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Associated Functions</h2>
	<ul style="font-size: 34px;">
		<li>Function that belongs to a struct or enum, rather than an instance of that struct or enum</li>
		<li>Associated functions are called using the name of the struct or enum, followed by the double colon (<a>::</a>) operator</li>
	</ul>
	<pre data-id="code-animation" style="font-size: 21px;">
		Example of an associated function `<a>new</a>` that acts as a constructor
		<code class="hljs rust" data-trim data-line-numbers>
			struct Point {
				x: i32,
				y: i32,
			}
			
			impl Point {
				fn new(x: i32, y: i32) -> Point {
					Point { x, y }
				}
			}
			fn main(){
				let p = Point::new(1, 2);
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Methods that access data</h3>
	<ul style="font-size: 32px;">
		<li>'new': a constructor that creates a new instance of the Rectangle struct</li>
		<li>'area': a method that calculates the area of the Rectangle and uses <strong>`<a href="https://doc.rust-lang.org/std/keyword.self.html" target="_blank">&self</a>`</strong> to access the data</li>
	</ul>
	<pre data-id="code-animation" style="font-size: 18px;">
		<code class="hljs rust" data-trim data-line-numbers>
			struct Rectangle {
				width: i32,
				height: i32,
			}
			
			impl Rectangle {
				fn new(width: i32, height: i32) -> Rectangle {
					Rectangle { width, height }
				}
				fn area(&self) -> i32 {
					self.width * self.height
				}
			}
			
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Closures</h2>
	<ul>
		<li><a href="https://doc.rust-lang.org/book/ch13-01-closures.html" target="_blank">Closure</a> is an anonymous function that can capture values from the enclosing environment and defined using the `<strong><a>||</a></strong>` characters</small></li>
		<li>Optional body delimination `{ }` for a single expression (mandatory otherwise)</li>
	</ul>
	
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>

    let print_text = | |  println!("Hello, World!");
                     ~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~
                     ^                ^
                     |                |
           start of closure       Body of closure

		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Closures</h2>
	<p>Examples:</p>
	<pre data-id="code-animation" style="height: 480px; font-size: 20px;">
		<code class="hljs rust" data-trim data-line-numbers>
			fn call_function< F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {
				f(x)
			}

			fn return_function() -> Box < dyn Fn(i32) -> i32> {
				Box::new(|x: i32| -> i32 { x * x })
			}

			fn main(){
				// Closure
				let square = |x: i32| -> i32 { x * x };
				println!("The square of 2 is {}", square(2));

				// Closure can be passed as an argument to a function
				println!("The square of 2 is {}", call_function(square, 2));

				// Closure can be returned as a result from a function:
				let square = return_function();
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
| Title Slide for topic:  String type in rust                                 |
+----------------------------------------------------------------------------->
<section>
	<h1>Strings</h1>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Strings</h2>
	<p>There are two types of strings in Rust</p>
	<ul>
		<li><a href="https://doc.rust-lang.org/std/string/struct.String.html" target="_blank">String</a></li>
		<li><a href="https://doc.rust-lang.org/std/primitive.str.html" target="_blank">&str</a></li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>String</h2>
	<ul>
		<li>Implemented as a smart pointer, specifically a Vec<u8></li>
		<li>Heap allocated, growable</li>
		<li>Can be mutated</li>
		<li>Always be a valid UTF-8, not null terminated sequence</li>
	</ul>
	<!-- <pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			// creating a String using the String::new
			let s = String::new(); 
			//creating a String using the String::from function
			let s = String::from("hello"); 
			//converting a string slice &str to a String using the to_string method
			let s = "hello".to_string();
		</code>
	</pre> -->
</section>

<section>
	<h2>Deref and String</h2>
	<p>String implements <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html" target="_blank">Deref</a> trait, which means that you can pass a <a href="https://doc.rust-lang.org/std/string/struct.String.html" target="_blank">&String</a> to something expecting a &str, and it will just work:</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn accepts_str(s: &str) {
				// code ..
			}

			fn main(){
				let s = String::from("hello");
				accepts_str(&s);
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>&str</h2>
	<ul>
		<li>An immutable reference to a valid UTF-8 sequence</li>
		<li>May be anywhere, on the heap, stack, or in program memory</li>
		<li>Only seen as a borrowed value</li>
		<li>Has a fixed size, the value is known at run time</li>
	</ul>
	<!-- <pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			//creating an &str from a string literal
			let s = "hello";
			//creating an &str from a String:
			let s = String::from("hello");
			let str_slice = &s[0..2];
		</code>
	</pre> -->
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			let s: String = String::from("hello world");

			let world: &str = &s[6..11];
		</code>
	</pre>
	<img style="height: 500px;" data-src="images/string&str.svg">
</section>
<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->

<section>
	<h3>Initialization</h3>
	<p>String</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			// creating a String using the String::new
			let s = String::new(); 
			//creating a String using the String::from function
			let s = String::from("hello"); 
			//converting a `&str` to a `String` using the to_string method
			let s = "hello".to_string();
		</code>
		<p>Use `<a>String</a>` when you need to <a>modify</a> or <a>own</a> a string</p>
	</pre>
	<p>&str</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			//creating an &str from a string literal
			let s = "hello";
			//creating an &str from a String:
			let s = String::from("hello");
			let str_slice = &s[0..2];
		</code>
		<p>Use `<a>&str</a>` when you just want to <a>borrow</a> a reference to a string</p>
	</pre>
</section>


<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Operations on Strings</h3>
	<small>concatenation | appending | slicing | splitting | replacing | iterating | checking starts prefix | checking ends suffix</small>
	<pre data-id="code-animation" style="height: 420px;">
		<code class="hljs rust" data-trim data-line-numbers>
			let s1 = String::from("hello world");
			let mut s2 = String::from("rust is awesome");

			let s3 = s1 + &s2;             // Concat using the `+` operator
			let s4 = format!("{}{}",s1,s2);// Concat using the format! macro
			s2.push_str(", & memory safe");// Appending using the push_str
			let slice = &s1[0..2];          // Slicing using string indices

			for c in "hello".chars() {     // Iterating over the string
				println!("{}", c);
			}
			println!("Length:{}", s1.len());// Finding the length of a string
			if(s1.starts_with("he")){}     // Check if starts with a prefix
			if(s1.ends_with("ld")){}       // Check if ends with a suffix
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/rust-tutorials-l2o26r?file=%2Fexample%2Fsplit.rs')"> examples in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/rust-tutorials-bwh2qz?file=%2Fexamples%2Fsplit.rs')"> in online editor</p> -->
	</pre>
</section>


<!----------------------------------------------------------------------------+
| Title Slide for topic: Ownership & Borrowing                                |
+----------------------------------------------------------------------------->
<section>
	<h1>Ownership & Borrowing</h1>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" target="_blank">Ownership</a></h3>
	<ul>
		<li>Every resource has a unique <strong><a>owner</a></strong></li>
		<li>The <strong>owner</strong> can change the owning value according to mutability</li>
		<li>Ownership <a>can be transferred</a> to an other variable</li>
		<li>Owner <a>cannot free or mutate</a> its resource <a>while it is borrowed</a></li>
		<li>Ownership model guarantees <a>safety</a></li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Ownership Rules</h3>
	<p>Each value in Rust has only <strong><a>one owner</a></strong></p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main () {
				let vector1 = vec![1, 2, 3];
			}			   
		</code>
	</pre>
	<p>here '<em>vector1</em>' is <strong><em>owner</em></strong></p>
	<pre data-id="code-animation" style="font-size: 21px;">
		<code class="hljs rust" data-trim data-line-numbers>
fn main () {
    let vector1 = vec![1, 2, 3];
                  ~~~~~~~~~~~~~  <---
                                     |
                              This memory
                            gets `deallocated`
}   <------------------------- here `vector1` goes out of scope
                          
		</code>
	</pre>
	<p>Value is <strong><a>dropped</a>,</strong></p> when owner <a>goes out of scope</a>.</p>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Ownership Rules</h3>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
fn main () {

  let vector1 = vec![1, 2, 3];  <--`vector1` is invalid variable
  let vector2 = vector1;                        beacause
      ~~~~~~~  <------------------ `vector2` is New Owner

  println!("{:?}",vector1);
}
		</code>
	</pre>

	<pre data-id="code-animation">
		Error:
		<code class="hljs rust" data-trim data-line-numbers>
error[E0382]: borrow of moved value: `vector1`
    --> src/main.rs:4:19
   |
2  |   let vector1 = vec![1, 2, 3];
   |       ------- move occurs because `vector1` has 
   |               type `Vec< i32>`, which does not implement 
   |               the `Copy` trait
3  |   let vector2 = vector1;
   |                 ------- value moved here
4  |   println!("{:?}",vector1);
   |                   ^^^^^^^ value borrowed here after move
		</code>
	</pre>

</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3><a href="https://doc.rust-lang.org/rust-by-example/scope/borrow.html" target="_blank">Borrowing</a></h3>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
    let vector2 = &vector1;
                  ^ -------------
    someFunction(&vector1);      |---> Reference
                 ^ --------------
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Borrowing Rules</h3>
	<p>All references are <strong><em><a>immutable</a></em></strong></p> by default.</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
fn main () {
  let mut vector1 = vec![1, 2, 3];
      ^^^  --------------------
  let vector2 = &mut vector1;  |---> Explicitly mentioned  
                 ^^^ ----------      as `mutable`
                                     using `mut` keyword
}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Borrowing Rules</h3>
	<p>Not <strong><a>more than one</a></strong></p> 'mutable reference' is allowed in <em>a scope</em></p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
fn main () {
   let mut _vector1 = vec![1, 2, 3];
   let _vector2 = &mut _vector1;
   let _vector3 = &mut _vector1;
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ---> NOT ALLOWED
}
		</code>
	</pre>
	<p>'mutable' and 'immutable' reference <strong><a>can not go hand in hand </a></strong><em>within a scope</em></p>

</section>

<!----------------------------------------------------------------------------+
| Title Slide for topic: Traits in rust                                       |
+----------------------------------------------------------------------------->
<section>
	<h1>Traits</h1>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<!-- <section>
	<h3><a href="https://doc.rust-lang.org/std/keyword.trait.html" target="_blank">Traits</a></h3>
	<ul>
		<li><strong><em>'Traits'</em></strong> are the abstract mechanism for adding functionality to types or it tells <em>Rust compiler</em> about functionality a type <strong><a>must</a></strong> provide</li>
		<li><strong><em>'Traits'</em></strong></a> are a way to group methods to define a set of <strong><a>behavior</a></strong> necessary to accomplish some purpose</li>
	</ul>
</section> -->

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<!-- <section>
	<h3>Trait Definition</h3>
	<ul>
		<li>Traits are defined by the <strong>`<a href="https://doc.rust-lang.org/std/keyword.trait.html" target="_blank">trait</a>`</strong> keyword followed by the name of the trait</li>
		<li>While defining any trait we have to provide method signatures (method declaration)</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			pub trait Calculator {
				fn add(&self) -> i32;
				fn sub(&self) -> i32;
				fn div(&self) -> i32;
				fn mul(&self) -> i32;
			}
		</code>
	</pre>
</section> -->

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<!-- <section>
	<h3>Trait implementation</h3>
	<ul>
		<li><strong>`<a href="https://doc.rust-lang.org/std/keyword.impl.html" target="_blank">impl</a>`</strong> keyword used to implement a trait</li>
		<li><strong>`<a href="https://doc.rust-lang.org/std/keyword.for.html" target="_blank">for</a>`</strong> is used when implementing traits as in impl Trait for Type</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			impl trait_name for type_name {
				
				//method definitions
			}
		</code>
	</pre>
</section> -->

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<!-- <section>
	<p><strong>Example</strong></p>
	<pre data-id="code-animation" style="width: 800px; height: 420px; font-size: 14px;">
		<code class="hljs rust" data-trim data-line-numbers>
			struct Calc {
				first_num: i32,
				second_num: i32
			}
			impl Calculator for Calc {
				fn add(&self) -> i32 {
					self.first_num + self.second_num
				}
				fn sub(&self) -> i32 {
					self.first_num - self.second_num
				}
				fn div(&self) -> i32 {
					self.first_num / self.second_num
				}
				fn mul(&self) -> i32 {
					self.first_num * self.second_num
				}
			}
			fn main() {
				println!("Output of Add: {}", Data {first_num:2, second_num: 2}.add());
				println!("Output of Sub: {}", Data {first_num:4, second_num: 2}.sub());
				println!("Output of Div: {}", Data {first_num:10, second_num: 2}.div());
				println!("Output of Mul: {}", Data {first_num:2, second_num: 2}.mul());
			}
		</code>
	</pre>
	<pre data-id="code-animation" style="width: 800px; font-size: 15px;">
		Output: 
		<code class="hljs rust" data-trim data-line-numbers>
		Compiling playground v0.0.1 (/playground)
		Finished dev [unoptimized + debuginfo] target(s) in 0.59s
			Running `target/debug/playground`

		Output of Add: 4
		Output of Sub: 2
		Output of Div: 5
		Output of Mul: 4
		</code>
	</pre>
</section> -->

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Default implementation of trait</h3>
	<ul>
		<li>Rust allows you to provide a default implementation of the Trait’s methods</li>
		<li>A Type can keep the implementation or can override also</li>
		<li>In the same Trait, default implementation can call another method also</li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<p><strong>Example</strong></p>
	<pre data-id="code-animation" style="width: 800px; height: 560px; font-size: 17px;">
		<code class="hljs rust" data-trim data-line-numbers>
			pub trait Calculator {
				fn add(&self) -> i32;
				fn sub(&self) -> i32;
				fn get_result(&self) {
					println!("The result of Addition is {}", self.add());
				}
			}
			
			struct calc {
				first_num: i32,
				second_num: i32
			}
			
			impl Calculator for calc {
				fn add(&self) -> i32 {
					self.first_num + self.second_num
				}
			
				fn sub(&self) -> i32 {
					self.first_num - self.second_num
				}
			}
			
			fn main() {
				Data {first_num:2, second_num: 2}.get_result();
				println!("Output of Sub: {}", Data {first_num:4, second_num: 2}.sub());
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Implement traits for existing types</h3>
	<ul style="font-size: 36px;"">
		<li>Unlike <em>interfaces</em> in languages like Java, new traits can be implemented for existing types</li>
		<li>For example, we can implement <strong><a>trait</a></strong> for existing types like bool, f32, i32, etc.</li>
	</ul>
	<pre data-id="code-animation" style="font-size: 18px;">
		<code class="hljs rust" data-trim data-line-numbers>
			trait PrintInfo {						//Define a trait called `PrintInfo`
				fn print_info(&self);	
			}
			
			impl PrintInfo for i32 {		// Implement `PrintInfo` for the built-in type `i32`
				fn print_info(&self) {
					println!("This is an integer: {}", self);
				}
			}
			
			fn main() {
				let num: i32 = 42;
				num.print_info(); 				// Output: "This is an integer: 42"
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Access Methods from the Same Trait</h3>
	<p>We can <a>access</a> other <a>methods</a> declared <a>in the same trait</a> using `<a>self</a>`</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			trait Calculator {
				fn add(&self) -> u32;
				// We can provide default method definitions.
				fn get_result(&self) {
					println!("Result of Add() is {}", self.add());
				}
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Passing Trait as a Function’s Parameters</h3>
	<p>Passing <em>trait</em> into a function’s parameter is a quite interesting concept in the traits environment so, with the help of this user can put the restriction into his functionality like only limit functions can able to use it.</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			pub fn calculate(item: impl Calculator) {
				println!("Addition {}", item.add());
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Trait Bound Concept</h3>
	<p>Trait Bound Concept is quite similar to the Passing Trait as a Function’s Parameters but with some syntactical differences.</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			pub fn calculate< T: Calculator> (item: T) {
				println!("Addition {}", item.add());
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->

<section>
	<h3><strong>+</strong> Operator & <strong>where</strong> Clause</h3>
	<p><strong><a>+</a></strong> operator is used to add more trait bound.</p>
	<pre data-id="code-animation" style="font-size: 19px;">
		<code class="hljs rust" data-trim data-line-numbers>
			pub fn calculate< T: Calculator + other_Trait> (item: T) -> u32 { 
				/// function's stuff
				
			}
		</code>
	</pre>

	<p style="font-size: 36px;"><strong>`<a href="https://doc.rust-lang.org/std/keyword.where.html" target="_blank">where</a>`</strong> clause is used to simplify the concept of Trait Bound like</p>
	<pre data-id="code-animation" style="font-size: 19px;">
		<code class="hljs rust" data-trim data-line-numbers>
			/// without where clause
			pub fn calculate< T:Calculator, U:Display> (item: T, data: U) -> u32 {
				/// function's stuff
			}
			
			///with where clause
			pub fn calculate< T, U> (item: T, data: U) -> u32 
			   where T: Calculator,
					 U: Display
			{
				/// function's stuff
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->

<section>
	<h3><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html" target="_blank">Lifetimes</a></h3>
	<ul style="font-size: 28px;">
		<li>It represents scope in which a reference is valid</li>
		<li>It ensures that references do not outlive the data they refer to</li>
		<li>By analyzing the lifetimes, the compiler can enforce memory safety</li>
		<li>Lifetimes are denoted by apostrophes ('), also known as "ticks" </li>
		<li>Often used in function signatures, struct definitions, and generic type parameters to specify the relationship between references</li>
	</ul>
	<pre data-id="code-animation" style="font-size: 18px;">
		<code class="hljs rust" data-trim data-line-numbers>
			fn longest_string<'a>(s1: &'a str, s2: &'a str) -> &'a str {
				if s1.len() > s2.len() {
					s1
				} else {
					s2
				}
			}
			
			fn main() {
				let s1 = "Hello";
				let s2 = "World";
				let result = longest_string(s1, s2);
				println!("Longest string: {}", result);
			}
		</code>
	</pre>
</section>


<section>
	<h3>Visibility Modifiers</h3>
	<ul style="font-size: 29px;">
		<li>It control the accessibility of structs, enums, functions, methods, and modules</li>
		<li>Rust provides three visibility modifiers:</li>
		<ul>
			<li><a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html?highlight=pub#visibility-and-privacy" target="_blank">`pub`</a>: accessible from other modules or crates</li>
			<li><a>`pub(crate)`</a>: accessible only within the same crate</li>
			<li><a>`pub(in path)`</a>: accessible only within the specified module path and its submodules.</li>
		</ul>
	</ul>
	<pre data-id="code-animation" style="font-size: 14px;">
		<code class="hljs rust" data-trim data-line-numbers>
			mod my_module {
				pub struct PublicStruct { } 
				struct PrivateStruct { }
				pub fn public_function() { }
				fn private_function() { }
				pub(crate) fn crate_function() { }
				pub(in crate::my_module::nested) fn restricted_function() { }
			}
			
			fn main() {
				let public_struct = my_module::PublicStruct {};
				my_module::public_function();
				// let private_struct = my_module::PrivateStruct {}; // Error: not accessible here
				// my_module::private_function(); 									// Error: not accessible here
			}
		</code>
	</pre>
</section>



<!----------------------------------------------------------------------------+
| Title Slide for topic: Memory management in rust                            |
+----------------------------------------------------------------------------->
<section class="r-fit-text">
	<h2>Memory Management</h2>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Memory Management</h2>
	<p style="font-size: 33px;">Rust program process is allocated some virtual memory by the Operating System(OS), this is the total memory that the process has access.</p>
	<img data-src="images/memory_structure.png" style="height: 400px;">
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Heap Memory</h2>
	<ul style="font-size: 36px;">
		<li>This is where all <a>dynamic data</a> (any data for which size cannot be calculated at compile time) <a>is stored</a></li>
		<li>This is the biggest block of memory and the part managed by Rust’s Ownership model</li>
		<li><strong>Box:</strong> The <a href="https://doc.rust-lang.org/stable/rust-by-example/std/box.html" target="_blank">Box type</a> is an abstraction for a heap-allocated value in Rust</li>
		<li>Heap memory is allocated when <a>Box::new</a> is called</li> 
		<li>A <a>Box < T ></a> holds the <a>smart-pointer</a> to the heap memory, allocated for type T and the <a>reference is saved on the Stack</a></li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Stack Memory</h2>
	<ul>
		<li>This is the stack memory area and there is <a>one stack per thread</a></li>
		<li>This is where <a>static values are allocated</a> by default </li>
		<li>Static data (data size known at compile time) includes function frames, primitive values, structs and pointers to dynamic data in Heap</li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Memory Usage</h2>
	<p>All values in Rust are allocated on the stack by default. There are two <a>exceptions</a> to this:</p>
	<ol>
		<li>When size of the value is dynamic like <a>Strings/Vectors</a></li>
		<li>When you manually create a <a>Box < T ></a> value which is allocated on heap</li>
	</ol>
	<p>In both cases, the value will be allocated on heap and its pointer will live on the stack.</p>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<!-- <section>
	<p>
		<img data-src="images/memory_usage_1.png" onclick="ChangeTransitionToFade();"></a>
	</p>
</section> -->

<section data-markdown data-transition="fade">
	<script type="text/template">
		![](images/memory_usage_1.png)

		---

		![](images/memory_usage_2.png)

		---

		![](images/memory_usage_3.png)

		---

		![](images/memory_usage_4.png)

		---

		![](images/memory_usage_5.png)

		---

		![](images/memory_usage_6.png)

		---

		![](images/memory_usage_7.png)

		---

		![](images/memory_usage_8.png)

		---

		![](images/memory_usage_9.png)

		---

		![](images/memory_usage_10.png)

		---

		![](images/memory_usage_11.png)

		---

		![](images/memory_usage_12.png)

		---

		![](images/memory_usage_13.png)
	</script>
</section>

<!-- <section>
	<p>
		<img data-src="images/memory_usage_13.png" onclick="ChangeTransitionToSlide();"></a>
	</p>
</section> -->

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section data-transition="convex">
	<h2>Smart Pointers</h2>
	<ul style="font-size: 36px;">
		<li>A <a>pointer</a> is a general concept for a variable that <a>contains an address in memory</a>.</li>
		<li>Smart pointers implement the `<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html" target="_blank">Deref</a>` and `<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html" target="_blank">Drop</a>` traits</li>
		<ul>
			<li>The Deref trait allows an instance of the smart pointer struct to behave like a reference so you can write your code to work with either references or smart pointers</li>
			<li>The Drop trait allows you to customize the code that automatically runs when an instance of the smart pointer goes out of scope</li>
		</ul>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Smart pointers in the std lib</h3>
	<ul style="font-size: 38px;">
		<li><a href="https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html" target="_blank">UnsafeCell< T ></a> used to represent a cell that can be mutated even when aliased or shared</li>
		<li>A mutable memory location. <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html" target="_blank">Cell< T ></a>  has the same in-memory representation as its inner type T</li>
		<li><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html" target="_blank">Box< T ></a> for allocating values on the heap</li>
		<li><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html" target="_blank">Rc< T ></a> for reference counting type that enables multiple ownership</li>
		<li><a href="https://doc.rust-lang.org/std/cell/struct.Ref.html" target="_blank">Ref< T ></a> and <a href="https://doc.rust-lang.org/std/cell/struct.RefMut.html" target="_blank">RefMut< T ></a>- accessed through <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html" target="_blank">RefCell< T ></a>- a type that enforces the borrowing rules at runtime instead of compile time</li>

	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->

<section>
	<h3><a href="https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html" target="_blank">UnsafeCell< T ></a></h3>
	<ul style="font-size: 32px;">
		<li>Provides a low-level mechanism to <a>mutate a value even when aliased or shared</a>, bypassing Rust's usual borrowing and ownership rules</li>
		<li>`UnsafeCell< T >` is essential for cases where you <a>need mutable access</a> to a value behind shared references but must <a>ensure safety yourself</a></li>
		<li>Usage of UnsafeCell< T > typically takes place <a>within unsafe blocks</a>, allowing controlled, low-level manipulation while adhering to Rust's safety principles</li>
	</ul>
	<!-- pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			// code here
		</code>
	</pre -->
</section>

<section>
	<h3><a href="https://doc.rust-lang.org/std/cell/struct.Cell.html" target="_blank">Cell< T ></a></h3>
	<ul>
		<li>`Cell< T >` has the same memory layout and caveats as `UnsafeCell< T >` </li>
		<li>This means that `Cell< T >` has the same in-memory representation as its inner type T </li>
	</ul>
	<!-- <pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
	
		</code>
	</pre> -->
</section>

<section>
	<h3><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html" target="_blank">Box< T ></a></h3>
	<ul>
		<li>Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data.</li>
		<li><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html" target="_blank">Box< T ></a> allows immutable or mutable borrows checked at compile time</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let b = Box::new(5);
				println!("b = {}", b);
			}			
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html" target="_blank">Rc< T ></a></h3>
	<ul style="font-size: 32px;">
		<li>Rc< T > : (reference counting) enables <a>multiple ownership</a> explicitly by using the Rust type</T></li>
		<li>The Rc< T > type keeps <a>track of the number of references</a> to a value to determine whether or not the value is still in use</li>
		<li>If there are <a>zero references</a> to a value, the value can be <a>cleaned up</a> without any references becoming invalid </li>
		<li>Rc< T > allows only <a>immutable borrows</a> checked at <a>compile time</a></li>
	</ul>
	<!-- pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			// code here
		</code>
	</pre -->
</section>

<section>
	<h3><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html" target="_blank">Rc< T ></a></h3>
	<img data-src="images/rc.png" style="height: 400px;">
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html" target="_blank">RefCell< T ></a></h3>
	<ul style="font-size: 32px;">
		<li>RefCell< T > type represents <a>single ownership</a> over the data it holds</li>
		<li>At any given time, you can have either (but not both) one mutable reference <a>or</a> any number of immutable references</li>
		<li>RefCell< T > allows immutable or mutable borrows <a>checked at runtime</a></li>
		<li><a>RefCell< T > </a> and <a>Box< T > </a>have <a>single owners</a>; Rc< T > enables <a>multiple owners</a> of the same data</li>
	</ul>
	<!-- pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			// code here
		</code>
	</pre -->
</section>

<!----------------------------------------------------------------------------+
| Title Slide for topic: Control flow                                         |
+----------------------------------------------------------------------------->
<section>
	<h1>Control Flow</h1>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>if expression</h3>
	<ul>
		<li>The most common way to introduce control flow and branch code</li>
		<li>Provide a condition and then execute the block of code if the condition is met</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() {
				let price: i32 = 10;
				if price > 0 {
				   println!(“true”);
				}
			}			 
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>if-else expression</h3>
	<ul>
		<li>An else expression can be added optionally</li>
		<li>If no else is provided the program will skip the if block if the condition is false</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let price: i32 = 10;
				if price > 0 {
				  println!(“true”);
				}
				else {
				  println!(“false”);
				}
			}						  
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>else-if expression</h3>
	<ul>
		<li>If you have more than two condition to check, if and else can be combined in else-if expression</li>
		<li>In the case all if and else if conditions evaluates to false, then the else block is executed</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let price: i32 = 10;
				if price == 1 {
				  println!(“price is 1.”);
					}
				else if price == 2 {
				  println!(“price is 2.”);
				}
				else {
				  println!(“other price”);
				}
			}							   
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3><a href="https://doc.rust-lang.org/std/keyword.match.html" target="_blank">match</a></h3>
	<ul style="font-size: 33px;">
		<li>Rust provides pattern matching with the match keyword</li>
		<li>Arms are evaluated and compared with the scrutineer expression</li>
		<li>Each arm has a pattern and some code. The `<a>=></a>` operator separates the pattern and the code to run</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let x = 1;
				match x {
				  1 => println!(“one”),
				  2 => println!(“two”),
				  3 => println!(“three”),
				  4 => println!(“four”),
				  5 => println!(“five”),
				  _ => println!(“something else”),
				}
			}									
		</code>
	</pre>
</section>


<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>loop</h3>
	<ul>
		<li>Used to execute over block of code <a><strong><em>forever</em></strong></a>, or until it is stopped, or the program quits</li>
		<li>Instead of having this <strong>`<a href="https://doc.rust-lang.org/std/keyword.loop.html" target="_blank">loop</a>`</strong> infinitely the <strong>`<a href="https://doc.rust-lang.org/std/keyword.break.html" target="_blank">break</a>`</strong> keyword can be used</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main() { 

				let mut i = 0; 
			  
				loop { 
				  i += 1; 
			  
				  if i > 100 { break; } 
				}
			} 								
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3><a href="https://doc.rust-lang.org/std/keyword.while.html" target="_blank">while</a></h3>
	<ul>
		<li>Conditional loops</li>
		<li>Run until the condition is met or becomes false</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){

				let mut num = 3;

				while num !=0 {

				  println!(“{}”, num);
				  num -= 1;

				}
				println!(“LIFTOFF!!”); 
			}						 
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>for loop</h3>
	<!-- <ul>
		<li>Iterate over a element in a collection</li>
		<li>Each pass of the loop extracts values</li>
	</ul> -->
	<ul>
		<li>Iterate over an element in a collection</li>
		<li>Every iteration of loop extracts values</li>
	</ul>

	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){

				let a = [10, 20, 30, 40, 50];

				for element in a.iter() {

				  println!(“the value is {}”, element);

				} 
			}				  
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>iterators</h3>
	<ul>
		<li>In Rust, iterators help us achieve the process of looping.</li>
		<li>Using the <a href="https://doc.rust-lang.org/stable/std/iter/" target="_blank"><strong><em>iter()</em></strong></a> function, we tell Rust that the given array can be used with a loop</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let a = [10, 20, 30, 40, 50];
				for element in a.iter() {
				  println!(“the value is {}”, element);
				} 
			}				   
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>iterator trait</h3>
	<ul>
		<li>In Rust, all iterators implement a trait named '<a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html" target="_blank">iterator</a>' that has a method called <a><strong><em>next()</em></strong></a></li>
		<li>Using the <a href="https://doc.rust-lang.org/stable/std/iter/" target="_blank"><strong><em>iter()</em></strong></a> function, we tell Rust that the given array can be used with a loop</li>
	</ul>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let a = [10, 20, 30, 40, 50];
				for element in a.iter() {
				  println!(“the value is {}”, element);
				} 
			}				   
		</code>
	</pre>
	<p>Any data type which implements <a><strong><em>next()</em></strong></a> method can be iterator.</p>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<p style="font-size: 52px;"><strong>Difference  in into_iter, iter, iter_mut</strong></p>
	<ul>
		<li><a><strong><em>into_iter:</em></strong></a> Consumes the collection, once the collection has been consumed, it is no longer available for reuse</li>
		<li><a><strong><em>iter:</em></strong></a> This borrows each element of the collection through each iteration, thus leaving the collection untouched and available for reuse after the loop</li>
		<li><a><strong><em>iter_mut:</em></strong></a> This mutably borrows each element of the collection, allowing for the collection to be modified in place</li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<p>Creating our own iterator</p>
	<pre data-id="code-animation" style="font-size: 14px; height: 470px;">
		<p style="font-size: 21px;">Example: </p>
		<code class="hljs rust" data-trim data-line-numbers>
			struct Counter {
				count: u32,
			}
			impl Counter {
				fn new() -> Counter {
					Counter { count: 0 }
				}
			}
			impl Iterator for Counter {
				type Item = u32;
				fn next(&mut self) -> Option< Self::Item> {
					if self.count < 5 {
						self.count += 1;
						Some(self.count)
					} else {
						None
					}
				}
			}
			fn main() {
				let mut counter = Counter::new();
				assert_eq!(counter.next(), Some(1));
				assert_eq!(counter.next(), Some(2));
				assert_eq!(counter.next(), Some(3));
				assert_eq!(counter.next(), Some(4));
				assert_eq!(counter.next(), Some(5));
				assert_eq!(counter.next(), None);
			}				   
		</code>
	</pre>
</section>

<section>
	<!-- <p>Creating our own iterator</p> -->
	<p>Excercise:</p>
	<pre data-id="code-animation" style="font-size: 14px; height: 470px;">
		<code class="hljs rust" data-trim data-line-numbers>
			struct Fibonacci {
				curr: u32,
				next: u32,
			}
			
			// Implement `Iterator` for `Fibonacci`.
			// The `Iterator` trait only requires a method to be defined for the `next` element.
			impl Iterator for Fibonacci {
				// We can refer to this type using Self::Item
				type Item = u32;
				
				/* Implement next method */
				fn next(&mut self)
			}
			
			// Returns a Fibonacci sequence generator
			fn fibonacci() -> Fibonacci {
				Fibonacci { curr: 0, next: 1 }
			}
			
			fn main() {
				let mut fib = fibonacci();
				assert_eq!(fib.next(), Some(1));
				assert_eq!(fib.next(), Some(1));
				assert_eq!(fib.next(), Some(2));
				assert_eq!(fib.next(), Some(3));
				assert_eq!(fib.next(), Some(5));
			}	   
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/iterator-forked-2pxyb0?file=%2Fsrc%2Fmain.rs')"> in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/iterator-forked-2pxyb0?file=%2Fsrc%2Fmain.rs')"> in online editor</p> -->
	</pre>
</section>


<!----------------------------------------------------------------------------+
| Title Slide for topic: Error handling in rust                               |
+----------------------------------------------------------------------------->
<section>
	<h1>Error Handling</h1>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Types of Error Handling</h3>
	<ul>
		<li>Error handling is the process of anticipating and working with the possibility of failure</li>
		<li>Learning how to handle errors in rust is the most effective and time saving</li>
		<li>There are two types of Errors in rust:</li>
		<ul>
			<li>Unrecoverable Errors</li>
			<li>Recoverable Errors</li>
		</ul>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Unrecoverable Errors</h2>
	<p>Unrecoverable errors are symptoms of bugs</p>
	<p><strong><a href="https://doc.rust-lang.org/std/macro.panic.html" target="_blank">panic!</a></strong> macro is the simplest way of handling errors</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
		fn main() {
			panic!("crash and burn");
		}
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2Fpanic1.rs')"> examples in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2Fpanic1.rs')"> in online editor</p> -->
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>What happens when panic is encountered?</h3>
	<ul>
		<li>Failure message is printed</li>
		<li>Program windups the stack </li>
		<li>Then it quits</li>
	</ul>
	<p></p>
	<h3>When to use panic?</h3>
	<p>
		Panic should be used only when a program comes to an <a>unrecoverable state</a>
	</p>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Recoverable Errors</h3>
	<p>Use of <strong><a href="https://doc.rust-lang.org/std/option/enum.Option.html" target="_blank">Option</a></strong> enum</p>
	<p>Most errors aren’t serious enough that requires a program to stop entirely</p>
	<aside class="notes">
		For example you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process
	</aside>
	<!-- <p><small>For example you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process</small></p> -->
	<p><strong><a href="https://doc.rust-lang.org/std/option/enum.Option.html" target="_blank">Option < T > </a></strong> enum is useful to handle non-existing values</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
		fn main(){
			enum Option< T > {
				Some(T),
				None,
			}
		}
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2FOption1.rs')"> examples in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2FOption1.rs')"> in online editor</p> -->
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Recoverable Errors</h2>
	<p>Use of <strong><a href="https://doc.rust-lang.org/std/result/enum.Result.html" target="_blank">Result </a></strong> enum</p>
	<p>Result type enum is used for most common errors, when an operation is expected to work but it does not</p>
	<!-- <p><small>For example you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process</small></p> -->
	<p><strong><a>Result  < T, E > </a></strong> enum is well suited when problems are expected</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
		fn main(){
			enum Result< T, E>{
				Ok(T),
				Err(E),
			}
		}
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2Fresult1.rs')"> examples in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2Fresult1.rs')"> in online editor</p> -->
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Helper Functions of Result Type</h2>
	<p>`<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap" target="_blank">unwrap</a>`</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
		use std::fs::File;
			fn main(){
			let f = File::open("hello.txt").unwrap();
		}
		</code>
	</pre>
	<p>`<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect" target="_blank">expect</a>`</p>
	<pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
use std::fs::File;
	fn main(){
	let f = File::open("hello.txt")
	              .expect("Failed to open hello.txt");
}
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2Fresult1.rs')"> examples in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2Fresult1.rs')"> in online editor</p> -->
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>The '?' operator</h2>
	<p>This is similar to match statement</p>
	<pre data-id="code-animation" style="font-size: 20px;">
		<code class="hljs rust" data-trim data-line-numbers>
		fn question() -> Result < (), Error> {
			// let x = ..
			match ultimate_answer(x) {
				Ok(_) => {},
				Err(err) => return Err(err.into()),
			};
			// code
		}
		</code>
	</pre>
	<p>The above code can be simplified using this <a>'?'</a></p>
	<pre data-id="code-animation" style="font-size: 20px;">
		<code class="hljs rust" data-trim data-line-numbers>
    fn question() -> Result < (), Error> {
        // let x = // ...
        ultimate_answer(x)?; // if `ultimate_answer` returns an error, 
                             //`question` stops here 
                             //and returns the error.
    }
		</code>
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="window.open('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2Fquestionmark.rs')"> examples in online editor</p> -->
		<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/p/sandbox/error-handling-clprht?file=%2Fexamples%2Fquestionmark.rs')"> in online editor</p> -->
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Error Propagation</h3>
	<ul style="font-size: 28px;">
		<li>Code must propagate error information <a>back to caller function</a> after detecting it</li>
		<li>One of the benefits is that your <a>code will look cleaner</a> by simply propagating error information back to the caller that can handle the error</li>
		<li>Other benefit is that your function <a>doesn’t need extra code</a> to propagate both the <a>successful</a> and <a>unsuccessful</a> cases</li>
	</ul>
	<pre data-id="code-animation">
		<code style="font-size: 16px;" class="hljs rust" data-trim data-line-numbers>
			fn open_file() -> Result< (), std::io::Error> {
				let file: Result< std::fs::File, std::io::Error> = std::fs::File::open("hello.txt");
				match file {
					Ok(_) => Ok(()), Err(e) => Err(e),
				}
			}
			fn main() {
				match open_file() {
					Ok(_) => println!("File is opened successfully!"),
					Err(e) => panic!( "Not able to open file. Here is the reason {:?}", e.to_string()),
				}
			}
		</code>
	</pre>
</section>


<section>
	<h3>Range and Bounds Checking</h3>
	<ul style="font-size: 33px;">
		<li><a>Range Checking</a> ensures that a value falls within a specific acceptable range or interval</li>
		<li><a>Bounds Checking</a> ensures that an index or reference to an element within a data structure (e.g. an array or slice) is within the valid bounds</li>
	</ul>
	<!-- <pre data-id="code-animation">
		<code class="hljs rust" data-trim data-line-numbers>
		</code>
	</pre> -->
</section>


<section>
	<h3>Range Checking</h3>
	<pre data-id="code-animation" style="font-size: 20px; width: 1100px;">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let value = 42;
				let lower_bound = 0;
				let upper_bound = 100;

				if(lower_bound..=upper_bound).contains(&value){
					println!("Value {} is within the range {}..={}", value, lower_bound, upper_bound);
				}else{
					println!("Value {} is outside the valid range {}..={}", value, lower_bound, upper_bound);
				}
			}
		</code>
	</pre>
</section>


<section>
	<h3>Bounds Checking</h3>
	<pre data-id="code-animation" style="font-size: 20px;">
		<code class="hljs rust" data-trim data-line-numbers>
			fn main(){
				let my_array = [1,2,3,4,5];
				let index = 7; //Trying to access out-of-bounds indexh
			
				let result = my_array.get(index);
			
				match result{
					Some(value) => println!("Value at index {} is {}",index, value),
					None => println!("Index {} is out of bounds for the array", index)
				}
			}
		</code>
	</pre>
</section>


<!----------------------------------------------------------------------------+
| Title Slide for topic: Concurrency in rust                                  |
+----------------------------------------------------------------------------->
<section class="r-fit-text">
	<h1>Concurrency</h1>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Fearless Concurrency</h2>
	<ul>
		<li><a>Message-passing</a> concurrency, where <em>'channels'</em> <a>send messages</a> between <strong>threads</strong> </li>
		<li><a>Shared-state</a> concurrency, where multiple <strong>threads</strong> have <a>access to same piece of data</a></li>
		<li>The <em><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html" target="_blank">Sync</a></em> and <em><a href="https://doc.rust-lang.org/std/marker/trait.Send.html" target="_blank">Send</a></em> traits, which extend Rust’s concurrency guarantees to user-defined types as well as types provided by the standard library</li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Creating a New Thread</h3>
	<p>To create a new thread, we call the <strong><a>thread::spawn</a></strong> function and pass it a <strong><a>closure</a></strong> containing the code we want to run in the new thread</p>
	<pre data-id="code-animation" style="height: 420px; font-size: 20px;">
		<code class="hljs rust" data-trim data-line-numbers>
		use std::thread;
		use std::time::Duration;
		
		fn main() {

			thread::spawn(|| {
				for i in 1..10 {
					println!("hi number {} from the spawned thread!", i);
					thread::sleep(Duration::from_millis(1));
				}
			});

			for i in 1..5 {
				println!("hi number {} from the main thread!", i);
				thread::sleep(Duration::from_millis(1));
			}
		}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Creating a New Channel</h3>
	<ul style="font-size: 32px;">
		<li><strong><a>Channel</a></strong> has two halves: <strong><a>transmitter</a></strong> and <strong><a>receiver</a></strong></li>
		<li>One thread uses transmitter to <strong><a>send</a></strong> data on the channel</li>
		<li>Other thread uses receiver to <strong><a>receive</a></strong> data from the channel</li>
		<li>Channel is <strong><a>closed</a></strong> if either transmitter or receiver is <strong><a>dropped</a></strong></li>
	</ul>
	<pre data-id="code-animation" style="height: 400px; font-size: 21px;">
		<code class="hljs rust" data-trim data-line-numbers>
		use std::sync::mpsc;
		use std::thread;
		
		fn main() {

			let (tx, rx) = mpsc::channel();
		
			thread::spawn(move || {
				let val = String::from("hi");
				tx.send(val).unwrap();
			});
		
			let received = rx.recv().unwrap();
			println!("Got: {}", received);
		}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Shared-State Concurrency</h3>
	<ul style="font-size: 32px;">
		<li>Shared memory concurrency is like <a>multiple ownership</a></li>
		<li>Multiple threads can access same data at the same time</li>
		<li>`Mutex` ensures access to shared data to only one thread at a time</li>
	</ul>
	<pre data-id="code-animation" style="height: 400px; font-size: 16px;">
		<code class="hljs rust" data-trim data-line-numbers>
		use std::sync::{Arc, Mutex};
		use std::thread;
		
		fn main() {
			let counter = Arc::new(Mutex::new(0));
			let mut handles = vec![];
		
			for _ in 0..10 {
				let counter = Arc::clone(&counter);
				let handle = thread::spawn(move || {
						let mut num = counter.lock().unwrap();
						*num += 1;
				});
				handles.push(handle);
			}
			for handle in handles {
				handle.join().unwrap();
			}
			println!("Result: {}", *counter.lock().unwrap());
		}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Send and Sync Traits</h2>
	<ul style="font-size: 34px;">
		<li>The <strong><a href="https://doc.rust-lang.org/std/marker/trait.Send.html" target="_blank">`Send` marker</a></strong> trait indicates that <a>ownership</a> of values of the type can be <a>transferred</a> between threads.</li>
		<li>The <strong><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html" target="_blank">`Sync` marker</a></strong> trait indicates that it is safe to be <a>shared</a> between threads</li>
		<li>Any type <strong><a>< T ></a></strong> is <strong><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html" target="_blank">Sync</a></strong> if <strong><a>&T</a></strong> is <strong><a href="https://doc.rust-lang.org/std/marker/trait.Send.html" target="_blank">Send</a></strong>, meaning the immutable reference can be sent safely to another thread</li>
		<li>Similar to Send, primitive types are Sync, and types composed entirely of types that are Sync are also Sync</li>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Send Trait</h2>
	<p style="font-size: 38px;">If a type implements <a>Send</a>, it is guaranteed to be <a>safe to `move`</a> between threads. It means that multiple threads can <a>use</a> a value of that type</p>
	<pre data-id="code-animation" style="font-size: 22px;">
		<code class="hljs rust" data-trim data-line-numbers>
		use std::thread;
		
		fn main(){

			let data = vec![1, 2, 3];
			thread::spawn(move || {
				println!("{:?}", data);
			});
		}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Sync Trait</h2>
	<p style="font-size: 33px;">If a type implements <a>Sync</a>, it is guaranteed to be <a>safe to share</a> between threads and a value of that type can be <a>accessed</a> in multiple threads at the <a>same time</a></p>
	<pre data-id="code-animation" style="font-size: 18px;">
		<code class="hljs rust" data-trim data-line-numbers>
		use std::sync::Arc;
		use std::thread;
		
		fn main(){
			let data = Arc::new(vec![1, 2, 3]);
			let data_clone = data.clone();
			
			thread::spawn(move || {
				println!("{:?}", data_clone);
			});
			
			println!("{:?}", data);
		}
		</code>
	</pre>
	<P style="font-size: 33px;">Use `Arc` instead of a raw pointer, it provides thread-safety and prevent data race conditions</P>
</section>

<!----------------------------------------------------------------------------+
| Title Slide for topic:  async/await pattern in rust                         |
+----------------------------------------------------------------------------->
<section>
	<h1>Async / Await</h1>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<p style="font-size: 60px;">What is async programming ?</p>
	<p>A concurrent programming model</p>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Multitasking</h2>
	<ul>
		<li>One of the fundamental features of most operating systems is multitasking, which is the ability to <a>execute multiple tasks concurrently</a></li>
		<br>
		
		<ul>
			<li><a>Pre-emptive Multitasking</a>
				<P style="font-size: 32px;">Pre-emptive multitasking is that the operating system controls when to switch tasks</P>
			</li>
			<li><a>Co-operative Multitasking</a>
				<p style="font-size: 32px;">Co-operative multitasking lets each task run until it voluntarily gives up control of the CPU</p>
			</li>
		</ul>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Async / Await</h2>
	<ul>
		<li>Built-in tool in rust programming for writing asynchronous functions</li>
		<br>
		<ul style="font-size: 34px;">
			<li><a href="https://doc.rust-lang.org/std/keyword.async.html" target="_blank">async</a>
				<P>Transforms a block of code into a state machine that <a>implements</a> a trait called <strong>'<a>future</a>'</strong>.</P>
			</li>
			<li><a href="https://doc.rust-lang.org/std/keyword.await.html" target="_blank">await</a>
				<ul>
					<li>Mechanism to run a future</li>
					<li>It asynchronously waits for the future to complete.</li>
				</ul>
			</li>
		</ul>
	</ul>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h2>Futures</h2>
	<ul style="font-size: 32px;">
		<li>A future represents a value that might not be available yet</li>
		<li>Futures make it possible to continue execution until the value is available</li>
	</ul>
	<pre data-id="code-animation" style="font-size: 20px;">
		<code class="hljs rust" data-trim data-line-numbers>

		let future = async_read_file("foo.txt");

		let file_content = loop {

			match future.poll(…) {

				Poll::Ready(value) => break value,
				Poll::Pending => {}, // do nothing

			}
		}
		</code>
	</pre>
	<pre data-id="code-animation" style="font-size: 20px;">
		<code class="hljs rust" data-trim data-line-numbers>
			pub enum Poll< T > {
				Ready(T),
				Pending,
			}
		</code>
	</pre>
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<section>
	<h3>Flow Diagram for `async`</h3>
	<img data-src="images/async_await_flow_diagram.png" style="height: 560px;">
</section>

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<!-- <section>
	<h3>The async/await Pattern</h3>
	<p>async/await pattern lets the programmer write code that looks like normal synchronous code, but the <a>compiler turns it into asynchronous</a> at compile time.</p>
	<pre data-id="code-animation" style="font-size: 21px;">
		<code class="hljs rust" data-trim data-line-numbers>
			async fn foo() -> u32 {
			    0
			}
		</code>
		<br>
		<p style="font-size: 30px;">Above code is roughly translated by the compiler to:</p>
		<br>
		<code class="hljs rust" data-trim data-line-numbers>
			fn foo() -> impl Future < Output = u32 > {
			    future::ready(0);
			}
		</code>
	</pre>
</section> -->

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->

<!-- <section>
	<h3>State Machine Transformation</h3>
	<pre data-id="code-animation" style="font-size: 21px;">
		<code class="hljs rust" data-trim data-line-numbers>
			async fn example(min_len: usize) -> String {
				let content = async_read_file("foo.txt").await;
				if content.len() < min_len {
					content + &async_read_file("bar.txt").await
				} else {
					content
				}
			}
		</code>
	</pre>
</section> -->


<!-- <section>
	<h3>State Machine Transformation</h3>
	<img data-src="images/state_machine.png">
</section> -->

<!----------------------------------------------------------------------------+
|                                                                             |
+----------------------------------------------------------------------------->
<!-- <section>
	<h2>Executors and Wakers</h2>
	<ul style="font-size: 32px;">
		<li><a>Executors</a>
			<ul>
				<li>Allows spawning futures as independent tasks, typically through some sort of '<a>spawn</a>' method</li>
				<li>Responsible for polling all futures until they are completed.</li>
				<li>Can switch to a different future whenever a future returns '<a>Poll::Pending</a>'</li>
			</ul>
		</li>
		<li><a>Wakers</a>
			<ul>
				<li>Wakers are objects that are used to wake up a task that is blocked waiting for some event to occur</li>
				<li>Wakers are typically created by executors and passed to tasks, allowing tasks to be woken up when the relevant event occurs</li>
			</ul>
		</li>
	</ul>
</section> -->

<section>
	<h1>Thank You</h1>
	<img src="images/rustacean.gif"></img>
	<!-- <p><input type="button" value="Run" class="RunButton" onclick="OpenEditor('https://codesandbox.io/s/2464zp59y')"> Open Editor</p> -->
</section>



<!----------------------------------------------------------------------------+
|        ************* CODE FOR SLIDES DECK ENDS HERE  *************          |
+----------------------------------------------------------------------------->
		</div>
	
</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<!-- <script src="js/jquery-3.6.3.min.js"></script> -->
		<script>

			var static_elements = document.getElementById("static-elements");
			static_elements.hidden = true;

			var slide_number = document.getElementById("slide-number");
			slide_number.onclick = function() {
				window.location.href = '#/1';
			}

			var SlidesDiv =  document.getElementById("SlidesDiv");
			var EditorDiv = document.getElementById("EditorDiv");
			var EditorFrame = document.getElementById("EditorFrame");
			var BackButton = document.getElementById("BackToPresentation");
			var CurrentURL = '';
			var isEditorOpen = false;

			var CloseEditor = function() {
				isEditorOpen = false;
				EditorDiv.style.display = "none"
				BackButton.style.display = "none";
				SlidesDiv.style.display = "block";
				Reveal.prev();
				Reveal.next();
			}

			var OpenEditor = function(url) {
				
				isEditorOpen = true;

				// window.open(url);

				SlidesDiv.style.display = "none"; 
				BackButton.style.display = "block";
				EditorDiv.style.display = "block";
				if(CurrentURL != url){
					CurrentURL = url;
					EditorFrame.src = url;
				};

				// SlidesDiv.hidden = true;
				// EditorDiv.hidden = false;

				// const iframeContainer = document.getElementById("EditorDiv");
				// const iframe = document.getElementById("iframe");
				// //check if an iframe exits. if it does, remove it and replace it with the new one
				// if (iframe) { iframeContainer.removeChild(iframe); }
				// const newIframe = document.createElement("iframe");
				// newIframe.src = url;
				// newIframe.id = "iframe";
				// newIframe.sandbox = "allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts allow-pointer-lock allow-top-navigation allow-orientation-lock";
				// newIframe.style.width = "100%";
				// newIframe.style.height = "800px";
				// newIframe.style.marginTop = "70px";
				// iframeContainer.appendChild(newIframe);
			}

			Reveal.addEventListener( 'slidechanged', function( event ) {
				EditorDiv.style.display = "none"
				BackButton.style.display = "none";
				SlidesDiv.style.display = "block";
				// EditorDiv.hidden = true;
				// SlidesDiv.hidden = false;

				if(isEditorOpen) {
					isEditorOpen = false;
					Reveal.prev();
					Reveal.next();
				};
				if(event.indexh>0) {
					static_elements.hidden = false;
					var number = "";
					number += event.indexh;
					if(event.indexv > 0)number += "."+event.indexv;
					slide_number.innerHTML = number;
				}else{
					static_elements.hidden = true;
				}
			});

			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/			
			Reveal.initialize({
				hash: true,
				transition: 'convex',
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
